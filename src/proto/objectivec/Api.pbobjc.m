// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Api.pbobjc.h"
 #import "Profile.pbobjc.h"
 #import "ProfileUserinfo.pbobjc.h"
 #import "Message.pbobjc.h"
 #import "Optional.pbobjc.h"
 #import "Prefs.pbobjc.h"
 #import "HubBase.pbobjc.h"
 #import "Struct.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ApiRoot

@implementation ApiRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[ProfileRoot extensionRegistry]];
    [registry addExtensions:[ProfileUserinfoRoot extensionRegistry]];
    [registry addExtensions:[MessageRoot extensionRegistry]];
    [registry addExtensions:[OptionalRoot extensionRegistry]];
    [registry addExtensions:[PrefsRoot extensionRegistry]];
    [registry addExtensions:[HubBaseRoot extensionRegistry]];
    [registry addExtensions:[StructRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - ApiRoot_FileDescriptor

static GPBFileDescriptor *ApiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CreateGroupErrorType

GPBEnumDescriptor *CreateGroupErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000NameInvalid\000NameTaken\000TitleImageInv"
        "alid\000BackgroundImageInvalid\000ServerError\000";
    static const int32_t values[] = {
        CreateGroupErrorType_None,
        CreateGroupErrorType_NameInvalid,
        CreateGroupErrorType_NameTaken,
        CreateGroupErrorType_TitleImageInvalid,
        CreateGroupErrorType_BackgroundImageInvalid,
        CreateGroupErrorType_ServerError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CreateGroupErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CreateGroupErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CreateGroupErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CreateGroupErrorType_None:
    case CreateGroupErrorType_NameInvalid:
    case CreateGroupErrorType_NameTaken:
    case CreateGroupErrorType_TitleImageInvalid:
    case CreateGroupErrorType_BackgroundImageInvalid:
    case CreateGroupErrorType_ServerError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ApiErrorCodes

GPBEnumDescriptor *ApiErrorCodes_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownError\000AuthMissingUserId\000ParamMiss"
        "ingChannelId\000ParamMissingUserId\000TimeoutI"
        "nvalidDuration\000TimeoutInvalidReason\000";
    static const int32_t values[] = {
        ApiErrorCodes_UnknownError,
        ApiErrorCodes_AuthMissingUserId,
        ApiErrorCodes_ParamMissingChannelId,
        ApiErrorCodes_ParamMissingUserId,
        ApiErrorCodes_TimeoutInvalidDuration,
        ApiErrorCodes_TimeoutInvalidReason,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ApiErrorCodes)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ApiErrorCodes_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ApiErrorCodes_IsValidValue(int32_t value__) {
  switch (value__) {
    case ApiErrorCodes_UnknownError:
    case ApiErrorCodes_AuthMissingUserId:
    case ApiErrorCodes_ParamMissingChannelId:
    case ApiErrorCodes_ParamMissingUserId:
    case ApiErrorCodes_TimeoutInvalidDuration:
    case ApiErrorCodes_TimeoutInvalidReason:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AuthLoginRequest

@implementation AuthLoginRequest

@dynamic username;
@dynamic password;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;

typedef struct AuthLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *username;
  NSString *password;
  NSString *agentId;
  NSString *agentName;
} AuthLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthLoginRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginRequest_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthLoginRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginRequest_FieldNumber_AgentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthLoginRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginRequest_FieldNumber_AgentName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthLoginRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = AuthLoginRequest_FieldNumber_AgentType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthLoginRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthLoginRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthLoginRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthLoginRequest_AgentType_RawValue(AuthLoginRequest *message) {
  GPBDescriptor *descriptor = [AuthLoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthLoginRequest_AgentType_RawValue(AuthLoginRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthLoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AuthLoginOAuthRequest

@implementation AuthLoginOAuthRequest

@dynamic oauthToken;
@dynamic oauthProvider;
@dynamic requestedUsername;
@dynamic emailAddress;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic oauthCode;
@dynamic oauthRedirectUri;

typedef struct AuthLoginOAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  AuthLoginOAuthRequest_OAuthProvider oauthProvider;
  UserAgent_UserAgentType agentType;
  NSString *oauthToken;
  NSString *requestedUsername;
  NSString *emailAddress;
  NSString *agentId;
  NSString *agentName;
  NSString *oauthCode;
  NSString *oauthRedirectUri;
} AuthLoginOAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oauthToken",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_OauthToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, oauthToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthProvider",
        .dataTypeSpecific.enumDescFunc = AuthLoginOAuthRequest_OAuthProvider_EnumDescriptor,
        .number = AuthLoginOAuthRequest_FieldNumber_OauthProvider,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, oauthProvider),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestedUsername",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_RequestedUsername,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, requestedUsername),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_EmailAddress,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_AgentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_AgentName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = AuthLoginOAuthRequest_FieldNumber_AgentType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "oauthCode",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_OauthCode,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, oauthCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthRedirectUri",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginOAuthRequest_FieldNumber_OauthRedirectUri,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AuthLoginOAuthRequest__storage_, oauthRedirectUri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthLoginOAuthRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthLoginOAuthRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthLoginOAuthRequest_OauthProvider_RawValue(AuthLoginOAuthRequest *message) {
  GPBDescriptor *descriptor = [AuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginOAuthRequest_FieldNumber_OauthProvider];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthLoginOAuthRequest_OauthProvider_RawValue(AuthLoginOAuthRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginOAuthRequest_FieldNumber_OauthProvider];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t AuthLoginOAuthRequest_AgentType_RawValue(AuthLoginOAuthRequest *message) {
  GPBDescriptor *descriptor = [AuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginOAuthRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthLoginOAuthRequest_AgentType_RawValue(AuthLoginOAuthRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginOAuthRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AuthLoginOAuthRequest_OAuthProvider

GPBEnumDescriptor *AuthLoginOAuthRequest_OAuthProvider_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Facebook\000Google\000";
    static const int32_t values[] = {
        AuthLoginOAuthRequest_OAuthProvider_Unknown,
        AuthLoginOAuthRequest_OAuthProvider_Facebook,
        AuthLoginOAuthRequest_OAuthProvider_Google,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthLoginOAuthRequest_OAuthProvider)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthLoginOAuthRequest_OAuthProvider_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthLoginOAuthRequest_OAuthProvider_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthLoginOAuthRequest_OAuthProvider_Unknown:
    case AuthLoginOAuthRequest_OAuthProvider_Facebook:
    case AuthLoginOAuthRequest_OAuthProvider_Google:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AuthLoginEmailRequest

@implementation AuthLoginEmailRequest

@dynamic email;
@dynamic sourceURL;
@dynamic code;
@dynamic requestedUsername;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic resetPassword;
@dynamic newPassword;

typedef struct AuthLoginEmailRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *email;
  NSString *sourceURL;
  NSString *code;
  NSString *requestedUsername;
  NSString *agentId;
  NSString *agentName;
  NSString *newPassword;
} AuthLoginEmailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_SourceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestedUsername",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_RequestedUsername,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, requestedUsername),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_AgentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_AgentName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = AuthLoginEmailRequest_FieldNumber_AgentType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resetPassword",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_ResetPassword,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginEmailRequest_FieldNumber_NewPassword,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AuthLoginEmailRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthLoginEmailRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthLoginEmailRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthLoginEmailRequest_AgentType_RawValue(AuthLoginEmailRequest *message) {
  GPBDescriptor *descriptor = [AuthLoginEmailRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginEmailRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthLoginEmailRequest_AgentType_RawValue(AuthLoginEmailRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthLoginEmailRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginEmailRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AuthLoginResponse

@implementation AuthLoginResponse

@dynamic success;
@dynamic token;
@dynamic hasUser, user;
@dynamic error;
@dynamic newUser;

typedef struct AuthLoginResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthLoginResponse_ErrorType error;
  NSString *token;
  User *user;
} AuthLoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthLoginResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = AuthLoginResponse_FieldNumber_User,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthLoginResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthLoginResponse_ErrorType_EnumDescriptor,
        .number = AuthLoginResponse_FieldNumber_Error,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthLoginResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "newUser",
        .dataTypeSpecific.className = NULL,
        .number = AuthLoginResponse_FieldNumber_NewUser,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthLoginResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthLoginResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthLoginResponse_Error_RawValue(AuthLoginResponse *message) {
  GPBDescriptor *descriptor = [AuthLoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthLoginResponse_Error_RawValue(AuthLoginResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthLoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthLoginResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AuthLoginResponse_ErrorType

GPBEnumDescriptor *AuthLoginResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000NewPassword"
        "Invalid\000IpBanned\000";
    static const int32_t values[] = {
        AuthLoginResponse_ErrorType_None,
        AuthLoginResponse_ErrorType_UnknownError,
        AuthLoginResponse_ErrorType_BadRequest,
        AuthLoginResponse_ErrorType_NewPasswordInvalid,
        AuthLoginResponse_ErrorType_IpBanned,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthLoginResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthLoginResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthLoginResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthLoginResponse_ErrorType_None:
    case AuthLoginResponse_ErrorType_UnknownError:
    case AuthLoginResponse_ErrorType_BadRequest:
    case AuthLoginResponse_ErrorType_NewPasswordInvalid:
    case AuthLoginResponse_ErrorType_IpBanned:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AuthWithTokenRequest

@implementation AuthWithTokenRequest

@dynamic token;

typedef struct AuthWithTokenRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} AuthWithTokenRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthWithTokenRequest_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthWithTokenRequest__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthWithTokenRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthWithTokenRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthWithTokenResponse

@implementation AuthWithTokenResponse

@dynamic success;
@dynamic token;

typedef struct AuthWithTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} AuthWithTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthWithTokenResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthWithTokenResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthWithTokenResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthWithTokenResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthWithTokenResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthRegisterRequest

@implementation AuthRegisterRequest

@dynamic username;
@dynamic password;
@dynamic email;
@dynamic inviteCode;
@dynamic newsletter;
@dynamic termsOfService;
@dynamic gosuInviteCode;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic ephemeral;
@dynamic joinCommunitiesArray, joinCommunitiesArray_Count;
@dynamic autoGenerateNameSuffix;
@dynamic avatarImage;

typedef struct AuthRegisterRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *username;
  NSString *password;
  NSString *email;
  NSString *inviteCode;
  NSString *gosuInviteCode;
  NSString *agentId;
  NSString *agentName;
  NSMutableArray *joinCommunitiesArray;
  NSString *avatarImage;
} AuthRegisterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_Email,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_InviteCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_Newsletter,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_TermsOfService,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gosuInviteCode",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_GosuInviteCode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, gosuInviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_AgentId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_AgentName,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = AuthRegisterRequest_FieldNumber_AgentType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ephemeral",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_Ephemeral,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinCommunitiesArray",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_JoinCommunitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, joinCommunitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoGenerateNameSuffix",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_AutoGenerateNameSuffix,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterRequest_FieldNumber_AvatarImage,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AuthRegisterRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthRegisterRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthRegisterRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthRegisterRequest_AgentType_RawValue(AuthRegisterRequest *message) {
  GPBDescriptor *descriptor = [AuthRegisterRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthRegisterRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthRegisterRequest_AgentType_RawValue(AuthRegisterRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthRegisterRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthRegisterRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AuthRegisterResponse

@implementation AuthRegisterResponse

@dynamic success;
@dynamic token;
@dynamic error;
@dynamic hasUser, user;
@dynamic autoGeneratedPassword;

typedef struct AuthRegisterResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthRegisterResponse_ErrorType error;
  NSString *token;
  User *user;
  NSString *autoGeneratedPassword;
} AuthRegisterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthRegisterResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthRegisterResponse_ErrorType_EnumDescriptor,
        .number = AuthRegisterResponse_FieldNumber_Error,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthRegisterResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = AuthRegisterResponse_FieldNumber_User,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthRegisterResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoGeneratedPassword",
        .dataTypeSpecific.className = NULL,
        .number = AuthRegisterResponse_FieldNumber_AutoGeneratedPassword,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthRegisterResponse__storage_, autoGeneratedPassword),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthRegisterResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthRegisterResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005U\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthRegisterResponse_Error_RawValue(AuthRegisterResponse *message) {
  GPBDescriptor *descriptor = [AuthRegisterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthRegisterResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthRegisterResponse_Error_RawValue(AuthRegisterResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthRegisterResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthRegisterResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AuthRegisterResponse_ErrorType

GPBEnumDescriptor *AuthRegisterResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UsernameTaken\000EmailTaken\000PwTooShort"
        "\000PwBad\000EmailInvalid\000ServerError\000Username"
        "Invalid\000DisplaynameTaken\000DisplaynameInva"
        "lid\000AvatarInvalid\000GroupInviteCodeInvalid"
        "\000GosuInviteCodeInvalid\000InviteCodeMissing"
        "\000BackgroundImageInvalid\000TitleImageInvali"
        "d\000IpBanned\000";
    static const int32_t values[] = {
        AuthRegisterResponse_ErrorType_None,
        AuthRegisterResponse_ErrorType_UsernameTaken,
        AuthRegisterResponse_ErrorType_EmailTaken,
        AuthRegisterResponse_ErrorType_PwTooShort,
        AuthRegisterResponse_ErrorType_PwBad,
        AuthRegisterResponse_ErrorType_EmailInvalid,
        AuthRegisterResponse_ErrorType_ServerError,
        AuthRegisterResponse_ErrorType_UsernameInvalid,
        AuthRegisterResponse_ErrorType_DisplaynameTaken,
        AuthRegisterResponse_ErrorType_DisplaynameInvalid,
        AuthRegisterResponse_ErrorType_AvatarInvalid,
        AuthRegisterResponse_ErrorType_GroupInviteCodeInvalid,
        AuthRegisterResponse_ErrorType_GosuInviteCodeInvalid,
        AuthRegisterResponse_ErrorType_InviteCodeMissing,
        AuthRegisterResponse_ErrorType_BackgroundImageInvalid,
        AuthRegisterResponse_ErrorType_TitleImageInvalid,
        AuthRegisterResponse_ErrorType_IpBanned,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthRegisterResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthRegisterResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthRegisterResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthRegisterResponse_ErrorType_None:
    case AuthRegisterResponse_ErrorType_UsernameTaken:
    case AuthRegisterResponse_ErrorType_EmailTaken:
    case AuthRegisterResponse_ErrorType_PwTooShort:
    case AuthRegisterResponse_ErrorType_PwBad:
    case AuthRegisterResponse_ErrorType_EmailInvalid:
    case AuthRegisterResponse_ErrorType_ServerError:
    case AuthRegisterResponse_ErrorType_UsernameInvalid:
    case AuthRegisterResponse_ErrorType_DisplaynameTaken:
    case AuthRegisterResponse_ErrorType_DisplaynameInvalid:
    case AuthRegisterResponse_ErrorType_AvatarInvalid:
    case AuthRegisterResponse_ErrorType_GroupInviteCodeInvalid:
    case AuthRegisterResponse_ErrorType_GosuInviteCodeInvalid:
    case AuthRegisterResponse_ErrorType_InviteCodeMissing:
    case AuthRegisterResponse_ErrorType_BackgroundImageInvalid:
    case AuthRegisterResponse_ErrorType_TitleImageInvalid:
    case AuthRegisterResponse_ErrorType_IpBanned:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AuthActivateResponse

@implementation AuthActivateResponse

@dynamic success;

typedef struct AuthActivateResponse__storage_ {
  uint32_t _has_storage_[1];
} AuthActivateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthActivateResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthActivateResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthActivateResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthPasswordResetRequest

@implementation AuthPasswordResetRequest

@dynamic email;
@dynamic sourceURL;

typedef struct AuthPasswordResetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *email;
  NSString *sourceURL;
} AuthPasswordResetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = AuthPasswordResetRequest_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthPasswordResetRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthPasswordResetRequest_FieldNumber_SourceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthPasswordResetRequest__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthPasswordResetRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthPasswordResetRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthPasswordResetResponse

@implementation AuthPasswordResetResponse

@dynamic success;

typedef struct AuthPasswordResetResponse__storage_ {
  uint32_t _has_storage_[1];
} AuthPasswordResetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthPasswordResetResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthPasswordResetResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthPasswordResetResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthGetPasswordResetInfoResponse

@implementation AuthGetPasswordResetInfoResponse

@dynamic error;
@dynamic hasUser, user;
@dynamic sourceURL;

typedef struct AuthGetPasswordResetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthGetPasswordResetInfoResponse_ErrorType error;
  ChatUser *user;
  NSString *sourceURL;
} AuthGetPasswordResetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthGetPasswordResetInfoResponse_ErrorType_EnumDescriptor,
        .number = AuthGetPasswordResetInfoResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthGetPasswordResetInfoResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = AuthGetPasswordResetInfoResponse_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthGetPasswordResetInfoResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthGetPasswordResetInfoResponse_FieldNumber_SourceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthGetPasswordResetInfoResponse__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthGetPasswordResetInfoResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthGetPasswordResetInfoResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuthGetPasswordResetInfoResponse_Error_RawValue(AuthGetPasswordResetInfoResponse *message) {
  GPBDescriptor *descriptor = [AuthGetPasswordResetInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthGetPasswordResetInfoResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuthGetPasswordResetInfoResponse_Error_RawValue(AuthGetPasswordResetInfoResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AuthGetPasswordResetInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuthGetPasswordResetInfoResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AuthGetPasswordResetInfoResponse_ErrorType

GPBEnumDescriptor *AuthGetPasswordResetInfoResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000Invalid\000";
    static const int32_t values[] = {
        AuthGetPasswordResetInfoResponse_ErrorType_None,
        AuthGetPasswordResetInfoResponse_ErrorType_UnknownError,
        AuthGetPasswordResetInfoResponse_ErrorType_Invalid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AuthGetPasswordResetInfoResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AuthGetPasswordResetInfoResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AuthGetPasswordResetInfoResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AuthGetPasswordResetInfoResponse_ErrorType_None:
    case AuthGetPasswordResetInfoResponse_ErrorType_UnknownError:
    case AuthGetPasswordResetInfoResponse_ErrorType_Invalid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AuthExecutePasswordResetRequest

@implementation AuthExecutePasswordResetRequest

@dynamic secret;
@dynamic newPassword;

typedef struct AuthExecutePasswordResetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *secret;
  NSString *newPassword;
} AuthExecutePasswordResetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "secret",
        .dataTypeSpecific.className = NULL,
        .number = AuthExecutePasswordResetRequest_FieldNumber_Secret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthExecutePasswordResetRequest__storage_, secret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = AuthExecutePasswordResetRequest_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthExecutePasswordResetRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthExecutePasswordResetRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthExecutePasswordResetRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthExecutePasswordResetResponse

@implementation AuthExecutePasswordResetResponse

@dynamic success;
@dynamic token;

typedef struct AuthExecutePasswordResetResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} AuthExecutePasswordResetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = AuthExecutePasswordResetResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthExecutePasswordResetResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthExecutePasswordResetResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthExecutePasswordResetResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthExecutePasswordResetResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileGetOwnProfileResponse

@implementation ProfileGetOwnProfileResponse

@dynamic hasUserInfo, userInfo;

typedef struct ProfileGetOwnProfileResponse__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *userInfo;
} ProfileGetOwnProfileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ProfileGetOwnProfileResponse_FieldNumber_UserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileGetOwnProfileResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileGetOwnProfileResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileGetOwnProfileResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileGetOtherProfileResponse

@implementation ProfileGetOtherProfileResponse

@dynamic hasUserInfo, userInfo;

typedef struct ProfileGetOtherProfileResponse__storage_ {
  uint32_t _has_storage_[1];
  ChatUserInfo *userInfo;
} ProfileGetOtherProfileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUserInfo),
        .number = ProfileGetOtherProfileResponse_FieldNumber_UserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileGetOtherProfileResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileGetOtherProfileResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileGetOtherProfileResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileUpdateRequest

@implementation ProfileUpdateRequest

@dynamic hasEmail, email;
@dynamic hasDisplayName, displayName;
@dynamic hasAvatarImage, avatarImage;
@dynamic status;
@dynamic hasTermsOfService, termsOfService;
@dynamic hasNewsletter, newsletter;
@dynamic hasBackgroundImage, backgroundImage;
@dynamic hasTitleImage, titleImage;
@dynamic hasBiography, biography;

typedef struct ProfileUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  User_UserStatus status;
  OptionalString *email;
  OptionalString *displayName;
  OptionalString *avatarImage;
  OptionalBool *termsOfService;
  OptionalBool *newsletter;
  OptionalString *backgroundImage;
  OptionalString *titleImage;
  BiographyUpdateData *biography;
} ProfileUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = ProfileUpdateRequest_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = ProfileUpdateRequest_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = ProfileUpdateRequest_FieldNumber_AvatarImage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = User_UserStatus_EnumDescriptor,
        .number = ProfileUpdateRequest_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalBool),
        .number = ProfileUpdateRequest_FieldNumber_TermsOfService,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, termsOfService),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalBool),
        .number = ProfileUpdateRequest_FieldNumber_Newsletter,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, newsletter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = ProfileUpdateRequest_FieldNumber_BackgroundImage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = ProfileUpdateRequest_FieldNumber_TitleImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "biography",
        .dataTypeSpecific.className = GPBStringifySymbol(BiographyUpdateData),
        .number = ProfileUpdateRequest_FieldNumber_Biography,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ProfileUpdateRequest__storage_, biography),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileUpdateRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileUpdateRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProfileUpdateRequest_Status_RawValue(ProfileUpdateRequest *message) {
  GPBDescriptor *descriptor = [ProfileUpdateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdateRequest_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetProfileUpdateRequest_Status_RawValue(ProfileUpdateRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [ProfileUpdateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdateRequest_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ProfileUpdateResponse

@implementation ProfileUpdateResponse

@dynamic error;
@dynamic hasUser, user;

typedef struct ProfileUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthRegisterResponse_ErrorType error;
  User *user;
} ProfileUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthRegisterResponse_ErrorType_EnumDescriptor,
        .number = ProfileUpdateResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileUpdateResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = ProfileUpdateResponse_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProfileUpdateResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileUpdateResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileUpdateResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProfileUpdateResponse_Error_RawValue(ProfileUpdateResponse *message) {
  GPBDescriptor *descriptor = [ProfileUpdateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdateResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetProfileUpdateResponse_Error_RawValue(ProfileUpdateResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ProfileUpdateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdateResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ProfileUpdatePasswordRequest

@implementation ProfileUpdatePasswordRequest

@dynamic oldPassword;
@dynamic newPassword;

typedef struct ProfileUpdatePasswordRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *oldPassword;
  NSString *newPassword;
} ProfileUpdatePasswordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldPassword",
        .dataTypeSpecific.className = NULL,
        .number = ProfileUpdatePasswordRequest_FieldNumber_OldPassword,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileUpdatePasswordRequest__storage_, oldPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = ProfileUpdatePasswordRequest_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProfileUpdatePasswordRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileUpdatePasswordRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileUpdatePasswordRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileUpdatePasswordResponse

@implementation ProfileUpdatePasswordResponse

@dynamic success;
@dynamic error;

typedef struct ProfileUpdatePasswordResponse__storage_ {
  uint32_t _has_storage_[1];
  ProfileUpdatePasswordResponse_ErrorType error;
} ProfileUpdatePasswordResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = ProfileUpdatePasswordResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = ProfileUpdatePasswordResponse_ErrorType_EnumDescriptor,
        .number = ProfileUpdatePasswordResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProfileUpdatePasswordResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileUpdatePasswordResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileUpdatePasswordResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProfileUpdatePasswordResponse_Error_RawValue(ProfileUpdatePasswordResponse *message) {
  GPBDescriptor *descriptor = [ProfileUpdatePasswordResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdatePasswordResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetProfileUpdatePasswordResponse_Error_RawValue(ProfileUpdatePasswordResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ProfileUpdatePasswordResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileUpdatePasswordResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ProfileUpdatePasswordResponse_ErrorType

GPBEnumDescriptor *ProfileUpdatePasswordResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000PwTooShort\000"
        "PwBad\000OldPwInvalid\000";
    static const int32_t values[] = {
        ProfileUpdatePasswordResponse_ErrorType_None,
        ProfileUpdatePasswordResponse_ErrorType_UnknownError,
        ProfileUpdatePasswordResponse_ErrorType_BadRequest,
        ProfileUpdatePasswordResponse_ErrorType_PwTooShort,
        ProfileUpdatePasswordResponse_ErrorType_PwBad,
        ProfileUpdatePasswordResponse_ErrorType_OldPwInvalid,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProfileUpdatePasswordResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProfileUpdatePasswordResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProfileUpdatePasswordResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProfileUpdatePasswordResponse_ErrorType_None:
    case ProfileUpdatePasswordResponse_ErrorType_UnknownError:
    case ProfileUpdatePasswordResponse_ErrorType_BadRequest:
    case ProfileUpdatePasswordResponse_ErrorType_PwTooShort:
    case ProfileUpdatePasswordResponse_ErrorType_PwBad:
    case ProfileUpdatePasswordResponse_ErrorType_OldPwInvalid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ProfileRequestFriendshipRequest

@implementation ProfileRequestFriendshipRequest

@dynamic userId;
@dynamic message;

typedef struct ProfileRequestFriendshipRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *message;
} ProfileRequestFriendshipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ProfileRequestFriendshipRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileRequestFriendshipRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ProfileRequestFriendshipRequest_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProfileRequestFriendshipRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileRequestFriendshipRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileRequestFriendshipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileRequestFriendshipResponse

@implementation ProfileRequestFriendshipResponse

@dynamic status;

typedef struct ProfileRequestFriendshipResponse__storage_ {
  uint32_t _has_storage_[1];
  ProfileRequestFriendshipResponse_FriendshipStatus status;
} ProfileRequestFriendshipResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ProfileRequestFriendshipResponse_FriendshipStatus_EnumDescriptor,
        .number = ProfileRequestFriendshipResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProfileRequestFriendshipResponse__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileRequestFriendshipResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileRequestFriendshipResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProfileRequestFriendshipResponse_Status_RawValue(ProfileRequestFriendshipResponse *message) {
  GPBDescriptor *descriptor = [ProfileRequestFriendshipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileRequestFriendshipResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetProfileRequestFriendshipResponse_Status_RawValue(ProfileRequestFriendshipResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ProfileRequestFriendshipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProfileRequestFriendshipResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ProfileRequestFriendshipResponse_FriendshipStatus

GPBEnumDescriptor *ProfileRequestFriendshipResponse_FriendshipStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Requested\000Accepted\000";
    static const int32_t values[] = {
        ProfileRequestFriendshipResponse_FriendshipStatus_None,
        ProfileRequestFriendshipResponse_FriendshipStatus_Requested,
        ProfileRequestFriendshipResponse_FriendshipStatus_Accepted,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProfileRequestFriendshipResponse_FriendshipStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProfileRequestFriendshipResponse_FriendshipStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProfileRequestFriendshipResponse_FriendshipStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProfileRequestFriendshipResponse_FriendshipStatus_None:
    case ProfileRequestFriendshipResponse_FriendshipStatus_Requested:
    case ProfileRequestFriendshipResponse_FriendshipStatus_Accepted:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ProfileUnfriendResponse

@implementation ProfileUnfriendResponse


typedef struct ProfileUnfriendResponse__storage_ {
  uint32_t _has_storage_[1];
} ProfileUnfriendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileUnfriendResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ProfileUnfriendResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProfileGetFriendsResponse

@implementation ProfileGetFriendsResponse

@dynamic friendsArray, friendsArray_Count;
@dynamic sentFriendRequestsArray, sentFriendRequestsArray_Count;
@dynamic receivedFriendRequestsArray, receivedFriendRequestsArray_Count;

typedef struct ProfileGetFriendsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *friendsArray;
  NSMutableArray *sentFriendRequestsArray;
  NSMutableArray *receivedFriendRequestsArray;
} ProfileGetFriendsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = ProfileGetFriendsResponse_FieldNumber_FriendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProfileGetFriendsResponse__storage_, friendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sentFriendRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendRequest),
        .number = ProfileGetFriendsResponse_FieldNumber_SentFriendRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProfileGetFriendsResponse__storage_, sentFriendRequestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receivedFriendRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendRequest),
        .number = ProfileGetFriendsResponse_FieldNumber_ReceivedFriendRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProfileGetFriendsResponse__storage_, receivedFriendRequestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProfileGetFriendsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProfileGetFriendsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserSetChannelRoleRequest

@implementation UserSetChannelRoleRequest

@dynamic userId;
@dynamic membershipType;

typedef struct UserSetChannelRoleRequest__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_MembershipType membershipType;
  NSString *userId;
} UserSetChannelRoleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserSetChannelRoleRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserSetChannelRoleRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membershipType",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = UserSetChannelRoleRequest_FieldNumber_MembershipType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserSetChannelRoleRequest__storage_, membershipType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserSetChannelRoleRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserSetChannelRoleRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserSetChannelRoleRequest_MembershipType_RawValue(UserSetChannelRoleRequest *message) {
  GPBDescriptor *descriptor = [UserSetChannelRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetChannelRoleRequest_FieldNumber_MembershipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserSetChannelRoleRequest_MembershipType_RawValue(UserSetChannelRoleRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [UserSetChannelRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetChannelRoleRequest_FieldNumber_MembershipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserSetChannelRoleResponse

@implementation UserSetChannelRoleResponse

@dynamic error;

typedef struct UserSetChannelRoleResponse__storage_ {
  uint32_t _has_storage_[1];
  UserSetChannelRoleResponse_ErrorType error;
} UserSetChannelRoleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserSetChannelRoleResponse_ErrorType_EnumDescriptor,
        .number = UserSetChannelRoleResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserSetChannelRoleResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserSetChannelRoleResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserSetChannelRoleResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserSetChannelRoleResponse_Error_RawValue(UserSetChannelRoleResponse *message) {
  GPBDescriptor *descriptor = [UserSetChannelRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetChannelRoleResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserSetChannelRoleResponse_Error_RawValue(UserSetChannelRoleResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserSetChannelRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetChannelRoleResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserSetChannelRoleResponse_ErrorType

GPBEnumDescriptor *UserSetChannelRoleResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Unknown\000UserNotInChannel\000Forbidden\000"
        "BadRequest\000";
    static const int32_t values[] = {
        UserSetChannelRoleResponse_ErrorType_None,
        UserSetChannelRoleResponse_ErrorType_Unknown,
        UserSetChannelRoleResponse_ErrorType_UserNotInChannel,
        UserSetChannelRoleResponse_ErrorType_Forbidden,
        UserSetChannelRoleResponse_ErrorType_BadRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserSetChannelRoleResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserSetChannelRoleResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserSetChannelRoleResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserSetChannelRoleResponse_ErrorType_None:
    case UserSetChannelRoleResponse_ErrorType_Unknown:
    case UserSetChannelRoleResponse_ErrorType_UserNotInChannel:
    case UserSetChannelRoleResponse_ErrorType_Forbidden:
    case UserSetChannelRoleResponse_ErrorType_BadRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserSetGroupRoleRequest

@implementation UserSetGroupRoleRequest

@dynamic userId;
@dynamic membershipType;

typedef struct UserSetGroupRoleRequest__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipRecord_MembershipType membershipType;
  NSString *userId;
} UserSetGroupRoleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserSetGroupRoleRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserSetGroupRoleRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membershipType",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = UserSetGroupRoleRequest_FieldNumber_MembershipType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserSetGroupRoleRequest__storage_, membershipType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserSetGroupRoleRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserSetGroupRoleRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserSetGroupRoleRequest_MembershipType_RawValue(UserSetGroupRoleRequest *message) {
  GPBDescriptor *descriptor = [UserSetGroupRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetGroupRoleRequest_FieldNumber_MembershipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserSetGroupRoleRequest_MembershipType_RawValue(UserSetGroupRoleRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [UserSetGroupRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetGroupRoleRequest_FieldNumber_MembershipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserSetGroupRoleResponse

@implementation UserSetGroupRoleResponse

@dynamic error;

typedef struct UserSetGroupRoleResponse__storage_ {
  uint32_t _has_storage_[1];
  UserSetGroupRoleResponse_ErrorType error;
} UserSetGroupRoleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserSetGroupRoleResponse_ErrorType_EnumDescriptor,
        .number = UserSetGroupRoleResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserSetGroupRoleResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserSetGroupRoleResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserSetGroupRoleResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserSetGroupRoleResponse_Error_RawValue(UserSetGroupRoleResponse *message) {
  GPBDescriptor *descriptor = [UserSetGroupRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetGroupRoleResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserSetGroupRoleResponse_Error_RawValue(UserSetGroupRoleResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserSetGroupRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserSetGroupRoleResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserSetGroupRoleResponse_ErrorType

GPBEnumDescriptor *UserSetGroupRoleResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Unknown\000UserNotInGroup\000Forbidden\000Ba"
        "dRequest\000";
    static const int32_t values[] = {
        UserSetGroupRoleResponse_ErrorType_None,
        UserSetGroupRoleResponse_ErrorType_Unknown,
        UserSetGroupRoleResponse_ErrorType_UserNotInGroup,
        UserSetGroupRoleResponse_ErrorType_Forbidden,
        UserSetGroupRoleResponse_ErrorType_BadRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserSetGroupRoleResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserSetGroupRoleResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserSetGroupRoleResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserSetGroupRoleResponse_ErrorType_None:
    case UserSetGroupRoleResponse_ErrorType_Unknown:
    case UserSetGroupRoleResponse_ErrorType_UserNotInGroup:
    case UserSetGroupRoleResponse_ErrorType_Forbidden:
    case UserSetGroupRoleResponse_ErrorType_BadRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserValidateUsernameRequest

@implementation UserValidateUsernameRequest

@dynamic username;

typedef struct UserValidateUsernameRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
} UserValidateUsernameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserValidateUsernameRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserValidateUsernameRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserValidateUsernameRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserValidateUsernameRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserValidateUsernameResponse

@implementation UserValidateUsernameResponse

@dynamic error;

typedef struct UserValidateUsernameResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthRegisterResponse_ErrorType error;
} UserValidateUsernameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthRegisterResponse_ErrorType_EnumDescriptor,
        .number = UserValidateUsernameResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserValidateUsernameResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserValidateUsernameResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserValidateUsernameResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserValidateUsernameResponse_Error_RawValue(UserValidateUsernameResponse *message) {
  GPBDescriptor *descriptor = [UserValidateUsernameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserValidateUsernameResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserValidateUsernameResponse_Error_RawValue(UserValidateUsernameResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserValidateUsernameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserValidateUsernameResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserValidateEmailAddressRequest

@implementation UserValidateEmailAddressRequest

@dynamic emailAddress;

typedef struct UserValidateEmailAddressRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *emailAddress;
} UserValidateEmailAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = UserValidateEmailAddressRequest_FieldNumber_EmailAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserValidateEmailAddressRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserValidateEmailAddressRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserValidateEmailAddressRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserValidateEmailAddressResponse

@implementation UserValidateEmailAddressResponse

@dynamic error;

typedef struct UserValidateEmailAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  UserValidateEmailAddressResponse_ErrorType error;
} UserValidateEmailAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserValidateEmailAddressResponse_ErrorType_EnumDescriptor,
        .number = UserValidateEmailAddressResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserValidateEmailAddressResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserValidateEmailAddressResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserValidateEmailAddressResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserValidateEmailAddressResponse_Error_RawValue(UserValidateEmailAddressResponse *message) {
  GPBDescriptor *descriptor = [UserValidateEmailAddressResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserValidateEmailAddressResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserValidateEmailAddressResponse_Error_RawValue(UserValidateEmailAddressResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserValidateEmailAddressResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserValidateEmailAddressResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserValidateEmailAddressResponse_ErrorType

GPBEnumDescriptor *UserValidateEmailAddressResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000EmailAddres"
        "sInvalid\000EmailAddressUnavailable\000";
    static const int32_t values[] = {
        UserValidateEmailAddressResponse_ErrorType_None,
        UserValidateEmailAddressResponse_ErrorType_UnknownError,
        UserValidateEmailAddressResponse_ErrorType_BadRequest,
        UserValidateEmailAddressResponse_ErrorType_EmailAddressInvalid,
        UserValidateEmailAddressResponse_ErrorType_EmailAddressUnavailable,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserValidateEmailAddressResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserValidateEmailAddressResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserValidateEmailAddressResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserValidateEmailAddressResponse_ErrorType_None:
    case UserValidateEmailAddressResponse_ErrorType_UnknownError:
    case UserValidateEmailAddressResponse_ErrorType_BadRequest:
    case UserValidateEmailAddressResponse_ErrorType_EmailAddressInvalid:
    case UserValidateEmailAddressResponse_ErrorType_EmailAddressUnavailable:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserConvertEphemeralUserRequest

@implementation UserConvertEphemeralUserRequest

@dynamic username;
@dynamic emailAddress;
@dynamic password;
@dynamic newsletter;
@dynamic termsOfService;
@dynamic avatarImage;

typedef struct UserConvertEphemeralUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *emailAddress;
  NSString *password;
  NSString *avatarImage;
} UserConvertEphemeralUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_EmailAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_Password,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_Newsletter,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_TermsOfService,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserRequest_FieldNumber_AvatarImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserConvertEphemeralUserRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserConvertEphemeralUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserConvertEphemeralUserResponse

@implementation UserConvertEphemeralUserResponse

@dynamic error;
@dynamic token;
@dynamic hasUser, user;

typedef struct UserConvertEphemeralUserResponse__storage_ {
  uint32_t _has_storage_[1];
  UserConvertEphemeralUserResponse_ErrorType error;
  NSString *token;
  User *user;
} UserConvertEphemeralUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserConvertEphemeralUserResponse_ErrorType_EnumDescriptor,
        .number = UserConvertEphemeralUserResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = UserConvertEphemeralUserResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = UserConvertEphemeralUserResponse_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserConvertEphemeralUserResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserConvertEphemeralUserResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserConvertEphemeralUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserConvertEphemeralUserResponse_Error_RawValue(UserConvertEphemeralUserResponse *message) {
  GPBDescriptor *descriptor = [UserConvertEphemeralUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserConvertEphemeralUserResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserConvertEphemeralUserResponse_Error_RawValue(UserConvertEphemeralUserResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserConvertEphemeralUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserConvertEphemeralUserResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserConvertEphemeralUserResponse_ErrorType

GPBEnumDescriptor *UserConvertEphemeralUserResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000UserNotEphe"
        "meral\000UsernameTaken\000UsernameInvalid\000Emai"
        "lTaken\000EmailInvalid\000PwTooShort\000PwBad\000";
    static const int32_t values[] = {
        UserConvertEphemeralUserResponse_ErrorType_None,
        UserConvertEphemeralUserResponse_ErrorType_BadRequest,
        UserConvertEphemeralUserResponse_ErrorType_UnknownError,
        UserConvertEphemeralUserResponse_ErrorType_UserNotEphemeral,
        UserConvertEphemeralUserResponse_ErrorType_UsernameTaken,
        UserConvertEphemeralUserResponse_ErrorType_UsernameInvalid,
        UserConvertEphemeralUserResponse_ErrorType_EmailTaken,
        UserConvertEphemeralUserResponse_ErrorType_EmailInvalid,
        UserConvertEphemeralUserResponse_ErrorType_PwTooShort,
        UserConvertEphemeralUserResponse_ErrorType_PwBad,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserConvertEphemeralUserResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserConvertEphemeralUserResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserConvertEphemeralUserResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserConvertEphemeralUserResponse_ErrorType_None:
    case UserConvertEphemeralUserResponse_ErrorType_BadRequest:
    case UserConvertEphemeralUserResponse_ErrorType_UnknownError:
    case UserConvertEphemeralUserResponse_ErrorType_UserNotEphemeral:
    case UserConvertEphemeralUserResponse_ErrorType_UsernameTaken:
    case UserConvertEphemeralUserResponse_ErrorType_UsernameInvalid:
    case UserConvertEphemeralUserResponse_ErrorType_EmailTaken:
    case UserConvertEphemeralUserResponse_ErrorType_EmailInvalid:
    case UserConvertEphemeralUserResponse_ErrorType_PwTooShort:
    case UserConvertEphemeralUserResponse_ErrorType_PwBad:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserTransferOwnershipRequest

@implementation UserTransferOwnershipRequest

@dynamic targetUserAuthToken;

typedef struct UserTransferOwnershipRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *targetUserAuthToken;
} UserTransferOwnershipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetUserAuthToken",
        .dataTypeSpecific.className = NULL,
        .number = UserTransferOwnershipRequest_FieldNumber_TargetUserAuthToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserTransferOwnershipRequest__storage_, targetUserAuthToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserTransferOwnershipRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserTransferOwnershipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserTransferOwnershipResponse

@implementation UserTransferOwnershipResponse

@dynamic error;

typedef struct UserTransferOwnershipResponse__storage_ {
  uint32_t _has_storage_[1];
  UserTransferOwnershipResponse_ErrorType error;
} UserTransferOwnershipResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserTransferOwnershipResponse_ErrorType_EnumDescriptor,
        .number = UserTransferOwnershipResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserTransferOwnershipResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserTransferOwnershipResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserTransferOwnershipResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserTransferOwnershipResponse_Error_RawValue(UserTransferOwnershipResponse *message) {
  GPBDescriptor *descriptor = [UserTransferOwnershipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserTransferOwnershipResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserTransferOwnershipResponse_Error_RawValue(UserTransferOwnershipResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserTransferOwnershipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserTransferOwnershipResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserTransferOwnershipResponse_ErrorType

GPBEnumDescriptor *UserTransferOwnershipResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000Forbidden\000UnknownError\000";
    static const int32_t values[] = {
        UserTransferOwnershipResponse_ErrorType_None,
        UserTransferOwnershipResponse_ErrorType_BadRequest,
        UserTransferOwnershipResponse_ErrorType_Forbidden,
        UserTransferOwnershipResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserTransferOwnershipResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserTransferOwnershipResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserTransferOwnershipResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserTransferOwnershipResponse_ErrorType_None:
    case UserTransferOwnershipResponse_ErrorType_BadRequest:
    case UserTransferOwnershipResponse_ErrorType_Forbidden:
    case UserTransferOwnershipResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserCheckBanStatusResponse

@implementation UserCheckBanStatusResponse

@dynamic error;
@dynamic isBanned;

typedef struct UserCheckBanStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  UserCheckBanStatusResponse_ErrorType error;
} UserCheckBanStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserCheckBanStatusResponse_ErrorType_EnumDescriptor,
        .number = UserCheckBanStatusResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserCheckBanStatusResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isBanned",
        .dataTypeSpecific.className = NULL,
        .number = UserCheckBanStatusResponse_FieldNumber_IsBanned,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCheckBanStatusResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserCheckBanStatusResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserCheckBanStatusResponse_Error_RawValue(UserCheckBanStatusResponse *message) {
  GPBDescriptor *descriptor = [UserCheckBanStatusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserCheckBanStatusResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserCheckBanStatusResponse_Error_RawValue(UserCheckBanStatusResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserCheckBanStatusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserCheckBanStatusResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserCheckBanStatusResponse_ErrorType

GPBEnumDescriptor *UserCheckBanStatusResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000";
    static const int32_t values[] = {
        UserCheckBanStatusResponse_ErrorType_None,
        UserCheckBanStatusResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserCheckBanStatusResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserCheckBanStatusResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserCheckBanStatusResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserCheckBanStatusResponse_ErrorType_None:
    case UserCheckBanStatusResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChatHandshakeResponse

@implementation ChatHandshakeResponse

@dynamic socketAddress;

typedef struct ChatHandshakeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *socketAddress;
} ChatHandshakeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "socketAddress",
        .dataTypeSpecific.className = NULL,
        .number = ChatHandshakeResponse_FieldNumber_SocketAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatHandshakeResponse__storage_, socketAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatHandshakeResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatHandshakeResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetMessagesResponse

@implementation ChatGetMessagesResponse

@dynamic messagesArray, messagesArray_Count;

typedef struct ChatGetMessagesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
} ChatGetMessagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = ChatGetMessagesResponse_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatGetMessagesResponse__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetMessagesResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetMessagesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetUsersResponse

@implementation ChatGetUsersResponse

@dynamic usersArray, usersArray_Count;

typedef struct ChatGetUsersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} ChatGetUsersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = ChatGetUsersResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatGetUsersResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetUsersResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetUsersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetChannelUsersResponse

@implementation ChatGetChannelUsersResponse

@dynamic usersArray, usersArray_Count;
@dynamic pagedUsers;
@dynamic from;
@dynamic onlineUsers;
@dynamic totalUsers;

typedef struct ChatGetChannelUsersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
  int64_t pagedUsers;
  int64_t from;
  int64_t onlineUsers;
  int64_t totalUsers;
} ChatGetChannelUsersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelUser),
        .number = ChatGetChannelUsersResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatGetChannelUsersResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pagedUsers",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetChannelUsersResponse_FieldNumber_PagedUsers,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatGetChannelUsersResponse__storage_, pagedUsers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetChannelUsersResponse_FieldNumber_From,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatGetChannelUsersResponse__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "onlineUsers",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetChannelUsersResponse_FieldNumber_OnlineUsers,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatGetChannelUsersResponse__storage_, onlineUsers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalUsers",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetChannelUsersResponse_FieldNumber_TotalUsers,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatGetChannelUsersResponse__storage_, totalUsers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetChannelUsersResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetChannelUsersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetChannelsResponse

@implementation ChatGetChannelsResponse

@dynamic channelsArray, channelsArray_Count;

typedef struct ChatGetChannelsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelsArray;
} ChatGetChannelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ChatGetChannelsResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatGetChannelsResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetChannelsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetChannelsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatPostJoinedChannelsRequest

@implementation ChatPostJoinedChannelsRequest

@dynamic channelIdsArray, channelIdsArray_Count;

typedef struct ChatPostJoinedChannelsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *channelIdsArray;
} ChatPostJoinedChannelsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ChatPostJoinedChannelsRequest_FieldNumber_ChannelIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatPostJoinedChannelsRequest__storage_, channelIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatPostJoinedChannelsRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatPostJoinedChannelsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetS3UploadDataResponse

@implementation ChatGetS3UploadDataResponse

@dynamic URL;
@dynamic accessKeyId;
@dynamic filename;
@dynamic policy;
@dynamic signed_p;

typedef struct ChatGetS3UploadDataResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *accessKeyId;
  NSString *filename;
  NSString *policy;
  NSString *signed_p;
} ChatGetS3UploadDataResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetS3UploadDataResponse_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatGetS3UploadDataResponse__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accessKeyId",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetS3UploadDataResponse_FieldNumber_AccessKeyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatGetS3UploadDataResponse__storage_, accessKeyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "filename",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetS3UploadDataResponse_FieldNumber_Filename,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatGetS3UploadDataResponse__storage_, filename),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "policy",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetS3UploadDataResponse_FieldNumber_Policy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatGetS3UploadDataResponse__storage_, policy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signed_p",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetS3UploadDataResponse_FieldNumber_Signed_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatGetS3UploadDataResponse__storage_, signed_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetS3UploadDataResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetS3UploadDataResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetDirectMessageChannelRequest

@implementation ChatGetDirectMessageChannelRequest

@dynamic userIdsArray, userIdsArray_Count;

typedef struct ChatGetDirectMessageChannelRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} ChatGetDirectMessageChannelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = ChatGetDirectMessageChannelRequest_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatGetDirectMessageChannelRequest__storage_, userIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetDirectMessageChannelRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetDirectMessageChannelRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatGetDirectMessageChannelResponse

@implementation ChatGetDirectMessageChannelResponse

@dynamic hasChannel, channel;

typedef struct ChatGetDirectMessageChannelResponse__storage_ {
  uint32_t _has_storage_[1];
  Channel *channel;
} ChatGetDirectMessageChannelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ChatGetDirectMessageChannelResponse_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatGetDirectMessageChannelResponse__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatGetDirectMessageChannelResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatGetDirectMessageChannelResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateGroupRequest

@implementation GroupCreateGroupRequest

@dynamic name;
@dynamic description_p;
@dynamic titleImage;
@dynamic backgroundImage;

typedef struct GroupCreateGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *description_p;
  NSString *titleImage;
  NSString *backgroundImage;
} GroupCreateGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateGroupRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateGroupRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateGroupRequest_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupCreateGroupRequest__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateGroupRequest_FieldNumber_TitleImage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupCreateGroupRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateGroupRequest_FieldNumber_BackgroundImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupCreateGroupRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateGroupRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateGroupResponse

@implementation GroupCreateGroupResponse

@dynamic error;
@dynamic hasGroup, group;

typedef struct GroupCreateGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  CreateGroupErrorType error;
  Group *group;
} GroupCreateGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = CreateGroupErrorType_EnumDescriptor,
        .number = GroupCreateGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupCreateGroupResponse_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupCreateGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateGroupResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupCreateGroupResponse_Error_RawValue(GroupCreateGroupResponse *message) {
  GPBDescriptor *descriptor = [GroupCreateGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupCreateGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupCreateGroupResponse_Error_RawValue(GroupCreateGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupCreateGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupCreateGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GroupEditGroupRequest

@implementation GroupEditGroupRequest

@dynamic id_p;
@dynamic hasName, name;
@dynamic hasDescription_p, description_p;
@dynamic hasTitleImage, titleImage;
@dynamic hasBackgroundImage, backgroundImage;

typedef struct GroupEditGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  OptionalString *name;
  OptionalString *description_p;
  OptionalString *titleImage;
  OptionalString *backgroundImage;
} GroupEditGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupEditGroupRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupEditGroupRequest__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = GroupEditGroupRequest_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupEditGroupRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = GroupEditGroupRequest_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupEditGroupRequest__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = GroupEditGroupRequest_FieldNumber_TitleImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupEditGroupRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = GroupEditGroupRequest_FieldNumber_BackgroundImage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupEditGroupRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupEditGroupRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupEditGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupEditGroupResponse

@implementation GroupEditGroupResponse

@dynamic error;
@dynamic hasGroup, group;

typedef struct GroupEditGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  CreateGroupErrorType error;
  Group *group;
} GroupEditGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = CreateGroupErrorType_EnumDescriptor,
        .number = GroupEditGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupEditGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupEditGroupResponse_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupEditGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupEditGroupResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupEditGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupEditGroupResponse_Error_RawValue(GroupEditGroupResponse *message) {
  GPBDescriptor *descriptor = [GroupEditGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupEditGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupEditGroupResponse_Error_RawValue(GroupEditGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupEditGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupEditGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GroupGetGroupResponse

@implementation GroupGetGroupResponse

@dynamic hasGroup, group;
@dynamic linkedHubsArray, linkedHubsArray_Count;

typedef struct GroupGetGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
  NSMutableArray *linkedHubsArray;
} GroupGetGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupGetGroupResponse_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupGetGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linkedHubsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Hub),
        .number = GroupGetGroupResponse_FieldNumber_LinkedHubsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupGetGroupResponse__storage_, linkedHubsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupGetGroupResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupGetGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateInviteCodeRequest

@implementation GroupCreateInviteCodeRequest

@dynamic groupId;

typedef struct GroupCreateInviteCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
} GroupCreateInviteCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateInviteCodeRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateInviteCodeRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateInviteCodeRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateInviteCodeRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateInviteCodeResponse

@implementation GroupCreateInviteCodeResponse

@dynamic inviteCode;

typedef struct GroupCreateInviteCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} GroupCreateInviteCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateInviteCodeResponse_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateInviteCodeResponse__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateInviteCodeResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateInviteCodeResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupGetInviteCodeInfoRequest

@implementation GroupGetInviteCodeInfoRequest

@dynamic inviteCode;

typedef struct GroupGetInviteCodeInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} GroupGetInviteCodeInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupGetInviteCodeInfoRequest_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupGetInviteCodeInfoRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupGetInviteCodeInfoRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupGetInviteCodeInfoRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupGetInviteCodeInfoResponse

@implementation GroupGetInviteCodeInfoResponse

@dynamic hasGroup, group;

typedef struct GroupGetInviteCodeInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
} GroupGetInviteCodeInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupGetInviteCodeInfoResponse_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupGetInviteCodeInfoResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupGetInviteCodeInfoResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupGetInviteCodeInfoResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAcceptInviteRequest

@implementation GroupAcceptInviteRequest

@dynamic inviteCode;

typedef struct GroupAcceptInviteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} GroupAcceptInviteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptInviteRequest_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAcceptInviteRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAcceptInviteRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAcceptInviteRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAcceptInviteResponse

@implementation GroupAcceptInviteResponse

@dynamic success;

typedef struct GroupAcceptInviteResponse__storage_ {
  uint32_t _has_storage_[1];
} GroupAcceptInviteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptInviteResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAcceptInviteResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAcceptInviteResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupLeaveGroupRequest

@implementation GroupLeaveGroupRequest

@dynamic groupId;

typedef struct GroupLeaveGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
} GroupLeaveGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupLeaveGroupRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupLeaveGroupRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupLeaveGroupRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupLeaveGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupLeaveGroupResponse

@implementation GroupLeaveGroupResponse

@dynamic hasUserInfo, userInfo;

typedef struct GroupLeaveGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *userInfo;
} GroupLeaveGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = GroupLeaveGroupResponse_FieldNumber_UserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupLeaveGroupResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupLeaveGroupResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupLeaveGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupGetGroupsResponse

@implementation GroupGetGroupsResponse

@dynamic groupsArray, groupsArray_Count;

typedef struct GroupGetGroupsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} GroupGetGroupsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupGetGroupsResponse_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupGetGroupsResponse__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupGetGroupsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupGetGroupsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAddGroupMembersRequest

@implementation GroupAddGroupMembersRequest

@dynamic groupId;
@dynamic inviteesArray, inviteesArray_Count;

typedef struct GroupAddGroupMembersRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *inviteesArray;
} GroupAddGroupMembersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupAddGroupMembersRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAddGroupMembersRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PotentialGroupMember),
        .number = GroupAddGroupMembersRequest_FieldNumber_InviteesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupAddGroupMembersRequest__storage_, inviteesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAddGroupMembersRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAddGroupMembersRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAddGroupMembersResponse

@implementation GroupAddGroupMembersResponse


typedef struct GroupAddGroupMembersResponse__storage_ {
  uint32_t _has_storage_[1];
} GroupAddGroupMembersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAddGroupMembersResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GroupAddGroupMembersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupJoinRequest

@implementation GroupJoinRequest

@dynamic code;

typedef struct GroupJoinRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *code;
} GroupJoinRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupJoinRequest_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupJoinRequest__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupJoinRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupJoinRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupJoinResponse

@implementation GroupJoinResponse

@dynamic error;

typedef struct GroupJoinResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupJoinResponse_ErrorType error;
} GroupJoinResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupJoinResponse_ErrorType_EnumDescriptor,
        .number = GroupJoinResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupJoinResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupJoinResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupJoinResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupJoinResponse_Error_RawValue(GroupJoinResponse *message) {
  GPBDescriptor *descriptor = [GroupJoinResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupJoinResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupJoinResponse_Error_RawValue(GroupJoinResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupJoinResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupJoinResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GroupJoinResponse_ErrorType

GPBEnumDescriptor *GroupJoinResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000Forbidden\000B"
        "anned\000InvalidCode\000";
    static const int32_t values[] = {
        GroupJoinResponse_ErrorType_None,
        GroupJoinResponse_ErrorType_UnknownError,
        GroupJoinResponse_ErrorType_BadRequest,
        GroupJoinResponse_ErrorType_Forbidden,
        GroupJoinResponse_ErrorType_Banned,
        GroupJoinResponse_ErrorType_InvalidCode,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupJoinResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupJoinResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupJoinResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupJoinResponse_ErrorType_None:
    case GroupJoinResponse_ErrorType_UnknownError:
    case GroupJoinResponse_ErrorType_BadRequest:
    case GroupJoinResponse_ErrorType_Forbidden:
    case GroupJoinResponse_ErrorType_Banned:
    case GroupJoinResponse_ErrorType_InvalidCode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GroupLeaveResponse

@implementation GroupLeaveResponse

@dynamic error;

typedef struct GroupLeaveResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupLeaveResponse_ErrorType error;
} GroupLeaveResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupLeaveResponse_ErrorType_EnumDescriptor,
        .number = GroupLeaveResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupLeaveResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupLeaveResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupLeaveResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupLeaveResponse_Error_RawValue(GroupLeaveResponse *message) {
  GPBDescriptor *descriptor = [GroupLeaveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupLeaveResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupLeaveResponse_Error_RawValue(GroupLeaveResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupLeaveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupLeaveResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GroupLeaveResponse_ErrorType

GPBEnumDescriptor *GroupLeaveResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000";
    static const int32_t values[] = {
        GroupLeaveResponse_ErrorType_None,
        GroupLeaveResponse_ErrorType_UnknownError,
        GroupLeaveResponse_ErrorType_BadRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupLeaveResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupLeaveResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupLeaveResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupLeaveResponse_ErrorType_None:
    case GroupLeaveResponse_ErrorType_UnknownError:
    case GroupLeaveResponse_ErrorType_BadRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GroupGetGroupTokenResponse

@implementation GroupGetGroupTokenResponse

@dynamic error;
@dynamic token;

typedef struct GroupGetGroupTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupGetGroupTokenResponse_ErrorType error;
  NSString *token;
} GroupGetGroupTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupGetGroupTokenResponse_ErrorType_EnumDescriptor,
        .number = GroupGetGroupTokenResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupGetGroupTokenResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = GroupGetGroupTokenResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupGetGroupTokenResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupGetGroupTokenResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupGetGroupTokenResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupGetGroupTokenResponse_Error_RawValue(GroupGetGroupTokenResponse *message) {
  GPBDescriptor *descriptor = [GroupGetGroupTokenResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupGetGroupTokenResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupGetGroupTokenResponse_Error_RawValue(GroupGetGroupTokenResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupGetGroupTokenResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupGetGroupTokenResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GroupGetGroupTokenResponse_ErrorType

GPBEnumDescriptor *GroupGetGroupTokenResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000BadRequest\000Forbidden\000";
    static const int32_t values[] = {
        GroupGetGroupTokenResponse_ErrorType_None,
        GroupGetGroupTokenResponse_ErrorType_UnknownError,
        GroupGetGroupTokenResponse_ErrorType_BadRequest,
        GroupGetGroupTokenResponse_ErrorType_Forbidden,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupGetGroupTokenResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupGetGroupTokenResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupGetGroupTokenResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupGetGroupTokenResponse_ErrorType_None:
    case GroupGetGroupTokenResponse_ErrorType_UnknownError:
    case GroupGetGroupTokenResponse_ErrorType_BadRequest:
    case GroupGetGroupTokenResponse_ErrorType_Forbidden:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PrefsGetPrefResponse

@implementation PrefsGetPrefResponse

@dynamic hasPref, pref;

typedef struct PrefsGetPrefResponse__storage_ {
  uint32_t _has_storage_[1];
  Pref *pref;
} PrefsGetPrefResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pref",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = PrefsGetPrefResponse_FieldNumber_Pref,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrefsGetPrefResponse__storage_, pref),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrefsGetPrefResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrefsGetPrefResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrefsGetPrefsResponse

@implementation PrefsGetPrefsResponse

@dynamic prefsArray, prefsArray_Count;

typedef struct PrefsGetPrefsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *prefsArray;
} PrefsGetPrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prefsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = PrefsGetPrefsResponse_FieldNumber_PrefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrefsGetPrefsResponse__storage_, prefsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrefsGetPrefsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrefsGetPrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrefsSetPrefsRequest

@implementation PrefsSetPrefsRequest

@dynamic prefsArray, prefsArray_Count;

typedef struct PrefsSetPrefsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *prefsArray;
} PrefsSetPrefsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prefsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = PrefsSetPrefsRequest_FieldNumber_PrefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PrefsSetPrefsRequest__storage_, prefsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrefsSetPrefsRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrefsSetPrefsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrefsSetPrefsResponse

@implementation PrefsSetPrefsResponse


typedef struct PrefsSetPrefsResponse__storage_ {
  uint32_t _has_storage_[1];
} PrefsSetPrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrefsSetPrefsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PrefsSetPrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PrefsDeletePrefsResponse

@implementation PrefsDeletePrefsResponse


typedef struct PrefsDeletePrefsResponse__storage_ {
  uint32_t _has_storage_[1];
} PrefsDeletePrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrefsDeletePrefsResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PrefsDeletePrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchSearchRequest

@implementation SearchSearchRequest

@dynamic searchTerm;
@dynamic limit;
@dynamic searchUsers;
@dynamic searchChannels;
@dynamic searchGroups;
@dynamic searchGames;
@dynamic searchTags;

typedef struct SearchSearchRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  NSString *searchTerm;
} SearchSearchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchTerm",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchTerm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchSearchRequest__storage_, searchTerm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchSearchRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "searchUsers",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchUsers,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchChannels",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchChannels,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchGroups",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchGroups,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchGames",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchGames,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchTags",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchRequest_FieldNumber_SearchTags,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchSearchRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchSearchRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchSearchResponse

@implementation SearchSearchResponse

@dynamic usersArray, usersArray_Count;
@dynamic channelsArray, channelsArray_Count;
@dynamic groupsArray, groupsArray_Count;
@dynamic gamesArray, gamesArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct SearchSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
  NSMutableArray *channelsArray;
  NSMutableArray *groupsArray;
  NSMutableArray *gamesArray;
  NSMutableArray *tagsArray;
} SearchSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = SearchSearchResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchSearchResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = SearchSearchResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchSearchResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = SearchSearchResponse_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchSearchResponse__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = SearchSearchResponse_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchSearchResponse__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = SearchSearchResponse_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchSearchResponse__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchSearchResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchSearchResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGetGameListResponse

@implementation ChannelGetGameListResponse

@dynamic hasPage, page;
@dynamic cacheId;

typedef struct ChannelGetGameListResponse__storage_ {
  uint32_t _has_storage_[1];
  GameListPage *page;
  NSString *cacheId;
} ChannelGetGameListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = GPBStringifySymbol(GameListPage),
        .number = ChannelGetGameListResponse_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelGetGameListResponse__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cacheId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelGetGameListResponse_FieldNumber_CacheId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelGetGameListResponse__storage_, cacheId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGetGameListResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelGetGameListResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelGetGameChannelListResponse

@implementation ChannelGetGameChannelListResponse

@dynamic hasPage, page;
@dynamic cacheId;

typedef struct ChannelGetGameChannelListResponse__storage_ {
  uint32_t _has_storage_[1];
  GameChannelListPage *page;
  NSString *cacheId;
} ChannelGetGameChannelListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = GPBStringifySymbol(GameChannelListPage),
        .number = ChannelGetGameChannelListResponse_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelGetGameChannelListResponse__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cacheId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelGetGameChannelListResponse_FieldNumber_CacheId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelGetGameChannelListResponse__storage_, cacheId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelGetGameChannelListResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelGetGameChannelListResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportRequest

@implementation ReportRequest

@dynamic userId;
@dynamic displayName;
@dynamic avatarImageURL;
@dynamic channelId;
@dynamic channelName;
@dynamic messageId;
@dynamic messageTimestamp;
@dynamic messageBody;
@dynamic reason;

typedef struct ReportRequest__storage_ {
  uint32_t _has_storage_[1];
  ReportRequest_Reason reason;
  NSString *userId;
  NSString *displayName;
  NSString *avatarImageURL;
  NSString *channelId;
  NSString *channelName;
  NSString *messageId;
  NSString *messageTimestamp;
  NSString *messageBody;
} ReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarImageURL",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_AvatarImageURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, avatarImageURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_ChannelId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_ChannelName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, channelName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_MessageId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_MessageTimestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, messageTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageBody",
        .dataTypeSpecific.className = NULL,
        .number = ReportRequest_FieldNumber_MessageBody,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, messageBody),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ReportRequest_Reason_EnumDescriptor,
        .number = ReportRequest_FieldNumber_Reason,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ReportRequest__storage_, reason),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\245\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ReportRequest_Reason_RawValue(ReportRequest *message) {
  GPBDescriptor *descriptor = [ReportRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReportRequest_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetReportRequest_Reason_RawValue(ReportRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [ReportRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ReportRequest_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ReportRequest_Reason

GPBEnumDescriptor *ReportRequest_Reason_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000AbusiveLanguage\000Griefing\000Mobbing"
        "\000Racism\000Spam\000Other\000";
    static const int32_t values[] = {
        ReportRequest_Reason_Unknown,
        ReportRequest_Reason_AbusiveLanguage,
        ReportRequest_Reason_Griefing,
        ReportRequest_Reason_Mobbing,
        ReportRequest_Reason_Racism,
        ReportRequest_Reason_Spam,
        ReportRequest_Reason_Other,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReportRequest_Reason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReportRequest_Reason_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReportRequest_Reason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReportRequest_Reason_Unknown:
    case ReportRequest_Reason_AbusiveLanguage:
    case ReportRequest_Reason_Griefing:
    case ReportRequest_Reason_Mobbing:
    case ReportRequest_Reason_Racism:
    case ReportRequest_Reason_Spam:
    case ReportRequest_Reason_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - APIError

@implementation APIError

@dynamic sourceOneOfCase;
@dynamic id_p;
@dynamic hasLinks, links;
@dynamic status;
@dynamic code;
@dynamic title;
@dynamic detail;
@dynamic pointer;
@dynamic parameter;
@dynamic hasMeta, meta;

typedef struct APIError__storage_ {
  uint32_t _has_storage_[2];
  NSString *id_p;
  Struct *links;
  NSString *title;
  NSString *detail;
  NSString *pointer;
  NSString *parameter;
  Struct *meta;
  int64_t status;
  int64_t code;
} APIError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(APIError__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "links",
        .dataTypeSpecific.className = GPBStringifySymbol(Struct),
        .number = APIError_FieldNumber_Links,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(APIError__storage_, links),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(APIError__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(APIError__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Title,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(APIError__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Detail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(APIError__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pointer",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Pointer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(APIError__storage_, pointer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "parameter",
        .dataTypeSpecific.className = NULL,
        .number = APIError_FieldNumber_Parameter,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(APIError__storage_, parameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meta",
        .dataTypeSpecific.className = GPBStringifySymbol(Struct),
        .number = APIError_FieldNumber_Meta,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(APIError__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[APIError class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(APIError__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "source",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void APIError_ClearSourceOneOfCase(APIError *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - CreateTimeoutRequest

@implementation CreateTimeoutRequest

@dynamic duration;
@dynamic reason;

typedef struct CreateTimeoutRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *reason;
  int64_t duration;
} CreateTimeoutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = CreateTimeoutRequest_FieldNumber_Duration,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateTimeoutRequest__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = CreateTimeoutRequest_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateTimeoutRequest__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTimeoutRequest class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTimeoutRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateTimeoutResponse

@implementation CreateTimeoutResponse

@dynamic success;
@dynamic errorsArray, errorsArray_Count;

typedef struct CreateTimeoutResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *errorsArray;
} CreateTimeoutResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = CreateTimeoutResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "errorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = CreateTimeoutResponse_FieldNumber_ErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateTimeoutResponse__storage_, errorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTimeoutResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTimeoutResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserEditBlockedUserResponse

@implementation UserEditBlockedUserResponse

@dynamic error;

typedef struct UserEditBlockedUserResponse__storage_ {
  uint32_t _has_storage_[1];
  UserEditBlockedUserResponse_ErrorType error;
} UserEditBlockedUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserEditBlockedUserResponse_ErrorType_EnumDescriptor,
        .number = UserEditBlockedUserResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserEditBlockedUserResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserEditBlockedUserResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserEditBlockedUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserEditBlockedUserResponse_Error_RawValue(UserEditBlockedUserResponse *message) {
  GPBDescriptor *descriptor = [UserEditBlockedUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserEditBlockedUserResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserEditBlockedUserResponse_Error_RawValue(UserEditBlockedUserResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserEditBlockedUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserEditBlockedUserResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserEditBlockedUserResponse_ErrorType

GPBEnumDescriptor *UserEditBlockedUserResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000";
    static const int32_t values[] = {
        UserEditBlockedUserResponse_ErrorType_None,
        UserEditBlockedUserResponse_ErrorType_BadRequest,
        UserEditBlockedUserResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserEditBlockedUserResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserEditBlockedUserResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserEditBlockedUserResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserEditBlockedUserResponse_ErrorType_None:
    case UserEditBlockedUserResponse_ErrorType_BadRequest:
    case UserEditBlockedUserResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserGetBlockedUsersResponse

@implementation UserGetBlockedUsersResponse

@dynamic error;
@dynamic usersArray, usersArray_Count;

typedef struct UserGetBlockedUsersResponse__storage_ {
  uint32_t _has_storage_[1];
  UserGetBlockedUsersResponse_ErrorType error;
  NSMutableArray *usersArray;
} UserGetBlockedUsersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserGetBlockedUsersResponse_ErrorType_EnumDescriptor,
        .number = UserGetBlockedUsersResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGetBlockedUsersResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = UserGetBlockedUsersResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserGetBlockedUsersResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGetBlockedUsersResponse class]
                                     rootClass:[ApiRoot class]
                                          file:ApiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGetBlockedUsersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserGetBlockedUsersResponse_Error_RawValue(UserGetBlockedUsersResponse *message) {
  GPBDescriptor *descriptor = [UserGetBlockedUsersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetBlockedUsersResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserGetBlockedUsersResponse_Error_RawValue(UserGetBlockedUsersResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [UserGetBlockedUsersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetBlockedUsersResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserGetBlockedUsersResponse_ErrorType

GPBEnumDescriptor *UserGetBlockedUsersResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000";
    static const int32_t values[] = {
        UserGetBlockedUsersResponse_ErrorType_None,
        UserGetBlockedUsersResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserGetBlockedUsersResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserGetBlockedUsersResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserGetBlockedUsersResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserGetBlockedUsersResponse_ErrorType_None:
    case UserGetBlockedUsersResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
