// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Rpc.pbobjc.h"
 #import "Api.pbobjc.h"
 #import "Profile.pbobjc.h"
 #import "ProfileUserinfo.pbobjc.h"
 #import "Optional.pbobjc.h"
 #import "Prefs.pbobjc.h"
 #import "Wrappers.pbobjc.h"
 #import "HubBase.pbobjc.h"
 #import "Hub.pbobjc.h"
 #import "Contacts.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RpcRoot

@implementation RpcRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[ApiRoot extensionRegistry]];
    [registry addExtensions:[ProfileRoot extensionRegistry]];
    [registry addExtensions:[ProfileUserinfoRoot extensionRegistry]];
    [registry addExtensions:[OptionalRoot extensionRegistry]];
    [registry addExtensions:[PrefsRoot extensionRegistry]];
    [registry addExtensions:[GPBWrappersRoot extensionRegistry]];
    [registry addExtensions:[HubBaseRoot extensionRegistry]];
    [registry addExtensions:[HubRoot extensionRegistry]];
    [registry addExtensions:[ContactsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - RpcRoot_FileDescriptor

static GPBFileDescriptor *RpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - RPCGenericResponse

@implementation RPCGenericResponse

@dynamic success;

typedef struct RPCGenericResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGenericResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCGenericResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGenericResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGenericResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCCreateRelationRequest

@implementation RPCCreateRelationRequest

@dynamic userId;
@dynamic type;

typedef struct RPCCreateRelationRequest__storage_ {
  uint32_t _has_storage_[1];
  ProprietaryUserGroupRecord_Type type;
  NSString *userId;
} RPCCreateRelationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCCreateRelationRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCCreateRelationRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ProprietaryUserGroupRecord_Type_EnumDescriptor,
        .number = RPCCreateRelationRequest_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCCreateRelationRequest__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCCreateRelationRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCCreateRelationRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCCreateRelationRequest_Type_RawValue(RPCCreateRelationRequest *message) {
  GPBDescriptor *descriptor = [RPCCreateRelationRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCCreateRelationRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCCreateRelationRequest_Type_RawValue(RPCCreateRelationRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCCreateRelationRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCCreateRelationRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCCreateRelationResponse

@implementation RPCCreateRelationResponse


typedef struct RPCCreateRelationResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCCreateRelationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCCreateRelationResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCCreateRelationResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCAuthLoginRequest

@implementation RPCAuthLoginRequest

@dynamic username;
@dynamic password;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic clientIp;
@dynamic currentUserId;

typedef struct RPCAuthLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *username;
  NSString *password;
  NSString *agentId;
  NSString *agentName;
  NSString *clientIp;
  NSString *currentUserId;
} RPCAuthLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_AgentId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_AgentName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = RPCAuthLoginRequest_FieldNumber_AgentType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_ClientIp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, clientIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentUserId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginRequest_FieldNumber_CurrentUserId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RPCAuthLoginRequest__storage_, currentUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAuthLoginRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAuthLoginRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCAuthLoginRequest_AgentType_RawValue(RPCAuthLoginRequest *message) {
  GPBDescriptor *descriptor = [RPCAuthLoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthLoginRequest_AgentType_RawValue(RPCAuthLoginRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthLoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCAuthLoginOAuthRequest

@implementation RPCAuthLoginOAuthRequest

@dynamic currentUserId;
@dynamic oauthToken;
@dynamic oauthProvider;
@dynamic requestedUsername;
@dynamic emailAddress;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic clientIp;
@dynamic oauthCode;
@dynamic oauthRedirectUri;

typedef struct RPCAuthLoginOAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  AuthLoginOAuthRequest_OAuthProvider oauthProvider;
  UserAgent_UserAgentType agentType;
  NSString *currentUserId;
  NSString *oauthToken;
  NSString *requestedUsername;
  NSString *emailAddress;
  NSString *agentId;
  NSString *agentName;
  NSString *clientIp;
  NSString *oauthCode;
  NSString *oauthRedirectUri;
} RPCAuthLoginOAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentUserId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_CurrentUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, currentUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthToken",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_OauthToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, oauthToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthProvider",
        .dataTypeSpecific.enumDescFunc = AuthLoginOAuthRequest_OAuthProvider_EnumDescriptor,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_OauthProvider,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, oauthProvider),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestedUsername",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_RequestedUsername,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, requestedUsername),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_EmailAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_AgentId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_AgentName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_AgentType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_ClientIp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, clientIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_OauthCode,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, oauthCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oauthRedirectUri",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginOAuthRequest_FieldNumber_OauthRedirectUri,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RPCAuthLoginOAuthRequest__storage_, oauthRedirectUri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAuthLoginOAuthRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAuthLoginOAuthRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCAuthLoginOAuthRequest_OauthProvider_RawValue(RPCAuthLoginOAuthRequest *message) {
  GPBDescriptor *descriptor = [RPCAuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginOAuthRequest_FieldNumber_OauthProvider];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthLoginOAuthRequest_OauthProvider_RawValue(RPCAuthLoginOAuthRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginOAuthRequest_FieldNumber_OauthProvider];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RPCAuthLoginOAuthRequest_AgentType_RawValue(RPCAuthLoginOAuthRequest *message) {
  GPBDescriptor *descriptor = [RPCAuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginOAuthRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthLoginOAuthRequest_AgentType_RawValue(RPCAuthLoginOAuthRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthLoginOAuthRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginOAuthRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCAuthLoginEmailRequest

@implementation RPCAuthLoginEmailRequest

@dynamic currentUserId;
@dynamic email;
@dynamic sourceURL;
@dynamic code;
@dynamic requestedUsername;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic clientIp;
@dynamic resetPassword;
@dynamic newPassword;

typedef struct RPCAuthLoginEmailRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *currentUserId;
  NSString *email;
  NSString *sourceURL;
  NSString *code;
  NSString *requestedUsername;
  NSString *agentId;
  NSString *agentName;
  NSString *clientIp;
  NSString *newPassword;
} RPCAuthLoginEmailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currentUserId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_CurrentUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, currentUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_Email,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_SourceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestedUsername",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_RequestedUsername,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, requestedUsername),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_AgentId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_AgentName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = RPCAuthLoginEmailRequest_FieldNumber_AgentType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_ClientIp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, clientIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resetPassword",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_ResetPassword,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginEmailRequest_FieldNumber_NewPassword,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RPCAuthLoginEmailRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAuthLoginEmailRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAuthLoginEmailRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCAuthLoginEmailRequest_AgentType_RawValue(RPCAuthLoginEmailRequest *message) {
  GPBDescriptor *descriptor = [RPCAuthLoginEmailRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginEmailRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthLoginEmailRequest_AgentType_RawValue(RPCAuthLoginEmailRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthLoginEmailRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginEmailRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCAuthLoginResponse

@implementation RPCAuthLoginResponse

@dynamic success;
@dynamic token;
@dynamic hasUser, user;
@dynamic error;
@dynamic newUser;

typedef struct RPCAuthLoginResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthLoginResponse_ErrorType error;
  NSString *token;
  User *user;
} RPCAuthLoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCAuthLoginResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RPCAuthLoginResponse_FieldNumber_User,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCAuthLoginResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthLoginResponse_ErrorType_EnumDescriptor,
        .number = RPCAuthLoginResponse_FieldNumber_Error,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCAuthLoginResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "newUser",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthLoginResponse_FieldNumber_NewUser,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAuthLoginResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAuthLoginResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCAuthLoginResponse_Error_RawValue(RPCAuthLoginResponse *message) {
  GPBDescriptor *descriptor = [RPCAuthLoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthLoginResponse_Error_RawValue(RPCAuthLoginResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthLoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthLoginResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCAuthRegisterRequest

@implementation RPCAuthRegisterRequest

@dynamic username;
@dynamic password;
@dynamic email;
@dynamic inviteCode;
@dynamic newsletter;
@dynamic termsOfService;
@dynamic gosuInviteCode;
@dynamic agentId;
@dynamic agentName;
@dynamic agentType;
@dynamic clientIp;
@dynamic languages;
@dynamic ephemeral;
@dynamic joinCommunitiesArray, joinCommunitiesArray_Count;
@dynamic autoGenerateNameSuffix;
@dynamic avatarImage;

typedef struct RPCAuthRegisterRequest__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType agentType;
  NSString *username;
  NSString *password;
  NSString *email;
  NSString *inviteCode;
  NSString *gosuInviteCode;
  NSString *agentId;
  NSString *agentName;
  NSString *clientIp;
  NSString *languages;
  NSMutableArray *joinCommunitiesArray;
  NSString *avatarImage;
} RPCAuthRegisterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Email,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_InviteCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Newsletter,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_TermsOfService,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gosuInviteCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_GosuInviteCode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, gosuInviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_AgentId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentName",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_AgentName,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, agentName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentType",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = RPCAuthRegisterRequest_FieldNumber_AgentType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, agentType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_ClientIp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, clientIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "languages",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Languages,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, languages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ephemeral",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_Ephemeral,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinCommunitiesArray",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_JoinCommunitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, joinCommunitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoGenerateNameSuffix",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_AutoGenerateNameSuffix,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = RPCAuthRegisterRequest_FieldNumber_AvatarImage,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RPCAuthRegisterRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAuthRegisterRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAuthRegisterRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCAuthRegisterRequest_AgentType_RawValue(RPCAuthRegisterRequest *message) {
  GPBDescriptor *descriptor = [RPCAuthRegisterRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthRegisterRequest_FieldNumber_AgentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCAuthRegisterRequest_AgentType_RawValue(RPCAuthRegisterRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCAuthRegisterRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCAuthRegisterRequest_FieldNumber_AgentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserConvertEphemeralUserRequest

@implementation RPCUserConvertEphemeralUserRequest

@dynamic userId;
@dynamic agentId;
@dynamic username;
@dynamic emailAddress;
@dynamic password;
@dynamic newsletter;
@dynamic termsOfService;
@dynamic avatarImage;

typedef struct RPCUserConvertEphemeralUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *agentId;
  NSString *username;
  NSString *emailAddress;
  NSString *password;
  NSString *avatarImage;
} RPCUserConvertEphemeralUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_AgentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_Username,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_EmailAddress,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_Password,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_Newsletter,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_TermsOfService,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserRequest_FieldNumber_AvatarImage,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserConvertEphemeralUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserConvertEphemeralUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserConvertEphemeralUserResponse

@implementation RPCUserConvertEphemeralUserResponse

@dynamic error;
@dynamic token;
@dynamic hasUser, user;

typedef struct RPCUserConvertEphemeralUserResponse__storage_ {
  uint32_t _has_storage_[1];
  UserConvertEphemeralUserResponse_ErrorType error;
  NSString *token;
  User *user;
} RPCUserConvertEphemeralUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserConvertEphemeralUserResponse_ErrorType_EnumDescriptor,
        .number = RPCUserConvertEphemeralUserResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserConvertEphemeralUserResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RPCUserConvertEphemeralUserResponse_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserConvertEphemeralUserResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserConvertEphemeralUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserConvertEphemeralUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserConvertEphemeralUserResponse_Error_RawValue(RPCUserConvertEphemeralUserResponse *message) {
  GPBDescriptor *descriptor = [RPCUserConvertEphemeralUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserConvertEphemeralUserResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserConvertEphemeralUserResponse_Error_RawValue(RPCUserConvertEphemeralUserResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserConvertEphemeralUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserConvertEphemeralUserResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCProfileGetRequest

@implementation RPCProfileGetRequest

@dynamic userId;

typedef struct RPCProfileGetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCProfileGetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCProfileGetRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCProfileGetRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCProfileGetRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCProfileGetRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserUpdateRequest

@implementation RPCUserUpdateRequest

@dynamic userId;
@dynamic hasEmail, email;
@dynamic hasDisplayName, displayName;
@dynamic hasAvatarImage, avatarImage;
@dynamic status;
@dynamic hasNewsletter, newsletter;
@dynamic hasGames, games;
@dynamic hasBackgroundImage, backgroundImage;
@dynamic hasTitleImage, titleImage;
@dynamic hasTermsOfService, termsOfService;
@dynamic hasBiography, biography;

typedef struct RPCUserUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  User_UserStatus status;
  NSString *userId;
  OptionalString *email;
  OptionalString *displayName;
  OptionalString *avatarImage;
  OptionalBool *newsletter;
  OptionalGames *games;
  OptionalString *backgroundImage;
  OptionalString *titleImage;
  OptionalBool *termsOfService;
  BiographyUpdateData *biography;
} RPCUserUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdateRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCUserUpdateRequest_FieldNumber_Email,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCUserUpdateRequest_FieldNumber_DisplayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCUserUpdateRequest_FieldNumber_AvatarImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = User_UserStatus_EnumDescriptor,
        .number = RPCUserUpdateRequest_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalBool),
        .number = RPCUserUpdateRequest_FieldNumber_Newsletter,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, newsletter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "games",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalGames),
        .number = RPCUserUpdateRequest_FieldNumber_Games,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, games),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCUserUpdateRequest_FieldNumber_BackgroundImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCUserUpdateRequest_FieldNumber_TitleImage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalBool),
        .number = RPCUserUpdateRequest_FieldNumber_TermsOfService,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, termsOfService),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "biography",
        .dataTypeSpecific.className = GPBStringifySymbol(BiographyUpdateData),
        .number = RPCUserUpdateRequest_FieldNumber_Biography,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RPCUserUpdateRequest__storage_, biography),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdateRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserUpdateRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserUpdateRequest_Status_RawValue(RPCUserUpdateRequest *message) {
  GPBDescriptor *descriptor = [RPCUserUpdateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateRequest_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserUpdateRequest_Status_RawValue(RPCUserUpdateRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserUpdateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateRequest_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserUpdateResponse

@implementation RPCUserUpdateResponse

@dynamic error;
@dynamic hasUser, user;

typedef struct RPCUserUpdateResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthRegisterResponse_ErrorType error;
  User *user;
} RPCUserUpdateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthRegisterResponse_ErrorType_EnumDescriptor,
        .number = RPCUserUpdateResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserUpdateResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RPCUserUpdateResponse_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserUpdateResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdateResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserUpdateResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserUpdateResponse_Error_RawValue(RPCUserUpdateResponse *message) {
  GPBDescriptor *descriptor = [RPCUserUpdateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserUpdateResponse_Error_RawValue(RPCUserUpdateResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserUpdateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserGetFriendsRequest

@implementation RPCUserGetFriendsRequest

@dynamic userId;

typedef struct RPCUserGetFriendsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserGetFriendsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetFriendsRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetFriendsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetFriendsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetFriendsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetFriendsResponse

@implementation RPCUserGetFriendsResponse

@dynamic friendsArray, friendsArray_Count;
@dynamic sentFriendRequestsArray, sentFriendRequestsArray_Count;
@dynamic receivedFriendRequestsArray, receivedFriendRequestsArray_Count;

typedef struct RPCUserGetFriendsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *friendsArray;
  NSMutableArray *sentFriendRequestsArray;
  NSMutableArray *receivedFriendRequestsArray;
} RPCUserGetFriendsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = RPCUserGetFriendsResponse_FieldNumber_FriendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCUserGetFriendsResponse__storage_, friendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sentFriendRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendRequest),
        .number = RPCUserGetFriendsResponse_FieldNumber_SentFriendRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCUserGetFriendsResponse__storage_, sentFriendRequestsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receivedFriendRequestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendRequest),
        .number = RPCUserGetFriendsResponse_FieldNumber_ReceivedFriendRequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCUserGetFriendsResponse__storage_, receivedFriendRequestsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetFriendsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetFriendsResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\000sentFriendRequests\000\003\000receivedFriendRe"
        "quests\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserFriendshipRequest

@implementation RPCUserFriendshipRequest

@dynamic sourceUser;
@dynamic targetUser;
@dynamic message;

typedef struct RPCUserFriendshipRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *sourceUser;
  NSString *targetUser;
  NSString *message;
} RPCUserFriendshipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceUser",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserFriendshipRequest_FieldNumber_SourceUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserFriendshipRequest__storage_, sourceUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUser",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserFriendshipRequest_FieldNumber_TargetUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserFriendshipRequest__storage_, targetUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserFriendshipRequest_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserFriendshipRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserFriendshipRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserFriendshipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserFriendshipRequestResponse

@implementation RPCUserFriendshipRequestResponse

@dynamic success;
@dynamic status;

typedef struct RPCUserFriendshipRequestResponse__storage_ {
  uint32_t _has_storage_[1];
  ProfileRequestFriendshipResponse_FriendshipStatus status;
} RPCUserFriendshipRequestResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserFriendshipRequestResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ProfileRequestFriendshipResponse_FriendshipStatus_EnumDescriptor,
        .number = RPCUserFriendshipRequestResponse_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserFriendshipRequestResponse__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserFriendshipRequestResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserFriendshipRequestResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserFriendshipRequestResponse_Status_RawValue(RPCUserFriendshipRequestResponse *message) {
  GPBDescriptor *descriptor = [RPCUserFriendshipRequestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserFriendshipRequestResponse_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserFriendshipRequestResponse_Status_RawValue(RPCUserFriendshipRequestResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserFriendshipRequestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserFriendshipRequestResponse_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserGetUserRequest

@implementation RPCUserGetUserRequest

@dynamic userId;
@dynamic username;
@dynamic email;
@dynamic ignoreChildren;
@dynamic normalizedUsername;

typedef struct RPCUserGetUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *username;
  NSString *email;
  NSString *normalizedUsername;
} RPCUserGetUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserRequest_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserGetUserRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserRequest_FieldNumber_Email,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserGetUserRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ignoreChildren",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserRequest_FieldNumber_IgnoreChildren,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "normalizedUsername",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserRequest_FieldNumber_NormalizedUsername,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCUserGetUserRequest__storage_, normalizedUsername),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserValidateUsernameRequest

@implementation RPCUserValidateUsernameRequest

@dynamic username;

typedef struct RPCUserValidateUsernameRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
} RPCUserValidateUsernameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserValidateUsernameRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserValidateUsernameRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserValidateUsernameRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserValidateUsernameRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserValidateUsernameResponse

@implementation RPCUserValidateUsernameResponse

@dynamic error;

typedef struct RPCUserValidateUsernameResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthRegisterResponse_ErrorType error;
} RPCUserValidateUsernameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthRegisterResponse_ErrorType_EnumDescriptor,
        .number = RPCUserValidateUsernameResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserValidateUsernameResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserValidateUsernameResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserValidateUsernameResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserValidateUsernameResponse_Error_RawValue(RPCUserValidateUsernameResponse *message) {
  GPBDescriptor *descriptor = [RPCUserValidateUsernameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserValidateUsernameResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserValidateUsernameResponse_Error_RawValue(RPCUserValidateUsernameResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserValidateUsernameResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserValidateUsernameResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserValidateEmailAddressRequest

@implementation RPCUserValidateEmailAddressRequest

@dynamic emailAddress;

typedef struct RPCUserValidateEmailAddressRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *emailAddress;
} RPCUserValidateEmailAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserValidateEmailAddressRequest_FieldNumber_EmailAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserValidateEmailAddressRequest__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserValidateEmailAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserValidateEmailAddressRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserValidateEmailAddressResponse

@implementation RPCUserValidateEmailAddressResponse

@dynamic error;

typedef struct RPCUserValidateEmailAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  UserValidateEmailAddressResponse_ErrorType error;
} RPCUserValidateEmailAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserValidateEmailAddressResponse_ErrorType_EnumDescriptor,
        .number = RPCUserValidateEmailAddressResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserValidateEmailAddressResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserValidateEmailAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserValidateEmailAddressResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserValidateEmailAddressResponse_Error_RawValue(RPCUserValidateEmailAddressResponse *message) {
  GPBDescriptor *descriptor = [RPCUserValidateEmailAddressResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserValidateEmailAddressResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserValidateEmailAddressResponse_Error_RawValue(RPCUserValidateEmailAddressResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserValidateEmailAddressResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserValidateEmailAddressResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserGetUserResponse

@implementation RPCUserGetUserResponse

@dynamic userExists;
@dynamic hasUser, user;

typedef struct RPCUserGetUserResponse__storage_ {
  uint32_t _has_storage_[1];
  User *user;
} RPCUserGetUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userExists",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserResponse_FieldNumber_UserExists,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RPCUserGetUserResponse_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserGetUserResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetUserAgentRequest

@implementation RPCUserGetUserAgentRequest

@dynamic agentId;
@dynamic populateUser;
@dynamic userId;

typedef struct RPCUserGetUserAgentRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *agentId;
  NSString *userId;
} RPCUserGetUserAgentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserAgentRequest_FieldNumber_AgentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetUserAgentRequest__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "populateUser",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserAgentRequest_FieldNumber_PopulateUser,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserAgentRequest_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCUserGetUserAgentRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetUserAgentRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetUserAgentRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetUserAgentResponse

@implementation RPCUserGetUserAgentResponse

@dynamic agentExists;
@dynamic hasAgent, agent;

typedef struct RPCUserGetUserAgentResponse__storage_ {
  uint32_t _has_storage_[1];
  UserAgent *agent;
} RPCUserGetUserAgentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agentExists",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetUserAgentResponse_FieldNumber_AgentExists,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "agent",
        .dataTypeSpecific.className = GPBStringifySymbol(UserAgent),
        .number = RPCUserGetUserAgentResponse_FieldNumber_Agent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserGetUserAgentResponse__storage_, agent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetUserAgentResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetUserAgentResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetOwnProfileRequest

@implementation RPCUserGetOwnProfileRequest

@dynamic userId;
@dynamic includeHubs;

typedef struct RPCUserGetOwnProfileRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserGetOwnProfileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetOwnProfileRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetOwnProfileRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "includeHubs",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetOwnProfileRequest_FieldNumber_IncludeHubs,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetOwnProfileRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetOwnProfileRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetOwnProfileResponse

@implementation RPCUserGetOwnProfileResponse

@dynamic hasUserInfo, userInfo;
@dynamic error;

typedef struct RPCUserGetOwnProfileResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCUserGetOwnProfileResponse_ErrorType error;
  UserInfo *userInfo;
} RPCUserGetOwnProfileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = RPCUserGetOwnProfileResponse_FieldNumber_UserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetOwnProfileResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCUserGetOwnProfileResponse_ErrorType_EnumDescriptor,
        .number = RPCUserGetOwnProfileResponse_FieldNumber_Error,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserGetOwnProfileResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetOwnProfileResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetOwnProfileResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserGetOwnProfileResponse_Error_RawValue(RPCUserGetOwnProfileResponse *message) {
  GPBDescriptor *descriptor = [RPCUserGetOwnProfileResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetOwnProfileResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserGetOwnProfileResponse_Error_RawValue(RPCUserGetOwnProfileResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserGetOwnProfileResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetOwnProfileResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RPCUserGetOwnProfileResponse_ErrorType

GPBEnumDescriptor *RPCUserGetOwnProfileResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000NotFound\000";
    static const int32_t values[] = {
        RPCUserGetOwnProfileResponse_ErrorType_None,
        RPCUserGetOwnProfileResponse_ErrorType_BadRequest,
        RPCUserGetOwnProfileResponse_ErrorType_UnknownError,
        RPCUserGetOwnProfileResponse_ErrorType_NotFound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RPCUserGetOwnProfileResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RPCUserGetOwnProfileResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RPCUserGetOwnProfileResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RPCUserGetOwnProfileResponse_ErrorType_None:
    case RPCUserGetOwnProfileResponse_ErrorType_BadRequest:
    case RPCUserGetOwnProfileResponse_ErrorType_UnknownError:
    case RPCUserGetOwnProfileResponse_ErrorType_NotFound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RPCUserGetOtherProfileRequest

@implementation RPCUserGetOtherProfileRequest

@dynamic userId;

typedef struct RPCUserGetOtherProfileRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserGetOtherProfileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetOtherProfileRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetOtherProfileRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetOtherProfileRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetOtherProfileRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetOtherProfileResponse

@implementation RPCUserGetOtherProfileResponse

@dynamic hasUserInfo, userInfo;

typedef struct RPCUserGetOtherProfileResponse__storage_ {
  uint32_t _has_storage_[1];
  ChatUserInfo *userInfo;
} RPCUserGetOtherProfileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUserInfo),
        .number = RPCUserGetOtherProfileResponse_FieldNumber_UserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetOtherProfileResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetOtherProfileResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetOtherProfileResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserActivationEmailRequest

@implementation RPCUserActivationEmailRequest

@dynamic userId;

typedef struct RPCUserActivationEmailRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserActivationEmailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserActivationEmailRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserActivationEmailRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserActivationEmailRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserActivationEmailRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserActivationEmailResponse

@implementation RPCUserActivationEmailResponse

@dynamic success;

typedef struct RPCUserActivationEmailResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCUserActivationEmailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserActivationEmailResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserActivationEmailResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserActivationEmailResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserExecuteActivationRequest

@implementation RPCUserExecuteActivationRequest

@dynamic secret;

typedef struct RPCUserExecuteActivationRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *secret;
} RPCUserExecuteActivationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "secret",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecuteActivationRequest_FieldNumber_Secret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserExecuteActivationRequest__storage_, secret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserExecuteActivationRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserExecuteActivationRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserExecuteActivationResponse

@implementation RPCUserExecuteActivationResponse

@dynamic success;

typedef struct RPCUserExecuteActivationResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCUserExecuteActivationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecuteActivationResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserExecuteActivationResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserExecuteActivationResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserPasswordResetEmailRequest

@implementation RPCUserPasswordResetEmailRequest

@dynamic email;
@dynamic sourceURL;

typedef struct RPCUserPasswordResetEmailRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *email;
  NSString *sourceURL;
} RPCUserPasswordResetEmailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserPasswordResetEmailRequest_FieldNumber_Email,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserPasswordResetEmailRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserPasswordResetEmailRequest_FieldNumber_SourceURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserPasswordResetEmailRequest__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserPasswordResetEmailRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserPasswordResetEmailRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserPasswordResetEmailResponse

@implementation RPCUserPasswordResetEmailResponse

@dynamic success;

typedef struct RPCUserPasswordResetEmailResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCUserPasswordResetEmailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserPasswordResetEmailResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserPasswordResetEmailResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserPasswordResetEmailResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetPasswordResetInfoRequest

@implementation RPCUserGetPasswordResetInfoRequest

@dynamic secret;

typedef struct RPCUserGetPasswordResetInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *secret;
} RPCUserGetPasswordResetInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "secret",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetPasswordResetInfoRequest_FieldNumber_Secret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetPasswordResetInfoRequest__storage_, secret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetPasswordResetInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetPasswordResetInfoRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetPasswordResetInfoResponse

@implementation RPCUserGetPasswordResetInfoResponse

@dynamic error;
@dynamic hasUser, user;
@dynamic sourceURL;

typedef struct RPCUserGetPasswordResetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthGetPasswordResetInfoResponse_ErrorType error;
  ChatUser *user;
  NSString *sourceURL;
} RPCUserGetPasswordResetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = AuthGetPasswordResetInfoResponse_ErrorType_EnumDescriptor,
        .number = RPCUserGetPasswordResetInfoResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetPasswordResetInfoResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = RPCUserGetPasswordResetInfoResponse_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserGetPasswordResetInfoResponse__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourceURL",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetPasswordResetInfoResponse_FieldNumber_SourceURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserGetPasswordResetInfoResponse__storage_, sourceURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetPasswordResetInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetPasswordResetInfoResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserGetPasswordResetInfoResponse_Error_RawValue(RPCUserGetPasswordResetInfoResponse *message) {
  GPBDescriptor *descriptor = [RPCUserGetPasswordResetInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetPasswordResetInfoResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserGetPasswordResetInfoResponse_Error_RawValue(RPCUserGetPasswordResetInfoResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserGetPasswordResetInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetPasswordResetInfoResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserExecutePasswordResetRequest

@implementation RPCUserExecutePasswordResetRequest

@dynamic secret;
@dynamic newPassword;

typedef struct RPCUserExecutePasswordResetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *secret;
  NSString *newPassword;
} RPCUserExecutePasswordResetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "secret",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecutePasswordResetRequest_FieldNumber_Secret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserExecutePasswordResetRequest__storage_, secret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecutePasswordResetRequest_FieldNumber_NewPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserExecutePasswordResetRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserExecutePasswordResetRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserExecutePasswordResetRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserExecutePasswordResetResponse

@implementation RPCUserExecutePasswordResetResponse

@dynamic success;
@dynamic token;

typedef struct RPCUserExecutePasswordResetResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} RPCUserExecutePasswordResetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecutePasswordResetResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserExecutePasswordResetResponse_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserExecutePasswordResetResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserExecutePasswordResetResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserExecutePasswordResetResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserUpdatePasswordRequest

@implementation RPCUserUpdatePasswordRequest

@dynamic userId;
@dynamic oldPassword;
@dynamic newPassword;

typedef struct RPCUserUpdatePasswordRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *oldPassword;
  NSString *newPassword;
} RPCUserUpdatePasswordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdatePasswordRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserUpdatePasswordRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oldPassword",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdatePasswordRequest_FieldNumber_OldPassword,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserUpdatePasswordRequest__storage_, oldPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPassword",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdatePasswordRequest_FieldNumber_NewPassword,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserUpdatePasswordRequest__storage_, newPassword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdatePasswordRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserUpdatePasswordRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserUpdatePasswordResponse

@implementation RPCUserUpdatePasswordResponse

@dynamic error;

typedef struct RPCUserUpdatePasswordResponse__storage_ {
  uint32_t _has_storage_[1];
  ProfileUpdatePasswordResponse_ErrorType error;
} RPCUserUpdatePasswordResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = ProfileUpdatePasswordResponse_ErrorType_EnumDescriptor,
        .number = RPCUserUpdatePasswordResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserUpdatePasswordResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdatePasswordResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserUpdatePasswordResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserUpdatePasswordResponse_Error_RawValue(RPCUserUpdatePasswordResponse *message) {
  GPBDescriptor *descriptor = [RPCUserUpdatePasswordResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdatePasswordResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserUpdatePasswordResponse_Error_RawValue(RPCUserUpdatePasswordResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserUpdatePasswordResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdatePasswordResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserSetChannelRoleRequest

@implementation RPCUserSetChannelRoleRequest

@dynamic userId;
@dynamic channelId;
@dynamic membershipType;

typedef struct RPCUserSetChannelRoleRequest__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_MembershipType membershipType;
  NSString *userId;
  NSString *channelId;
} RPCUserSetChannelRoleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserSetChannelRoleRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserSetChannelRoleRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserSetChannelRoleRequest_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserSetChannelRoleRequest__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membershipType",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = RPCUserSetChannelRoleRequest_FieldNumber_MembershipType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserSetChannelRoleRequest__storage_, membershipType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserSetChannelRoleRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserSetChannelRoleRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserSetChannelRoleRequest_MembershipType_RawValue(RPCUserSetChannelRoleRequest *message) {
  GPBDescriptor *descriptor = [RPCUserSetChannelRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetChannelRoleRequest_FieldNumber_MembershipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserSetChannelRoleRequest_MembershipType_RawValue(RPCUserSetChannelRoleRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserSetChannelRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetChannelRoleRequest_FieldNumber_MembershipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserSetChannelRoleResponse

@implementation RPCUserSetChannelRoleResponse

@dynamic error;

typedef struct RPCUserSetChannelRoleResponse__storage_ {
  uint32_t _has_storage_[1];
  UserSetChannelRoleResponse_ErrorType error;
} RPCUserSetChannelRoleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserSetChannelRoleResponse_ErrorType_EnumDescriptor,
        .number = RPCUserSetChannelRoleResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserSetChannelRoleResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserSetChannelRoleResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserSetChannelRoleResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserSetChannelRoleResponse_Error_RawValue(RPCUserSetChannelRoleResponse *message) {
  GPBDescriptor *descriptor = [RPCUserSetChannelRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetChannelRoleResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserSetChannelRoleResponse_Error_RawValue(RPCUserSetChannelRoleResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserSetChannelRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetChannelRoleResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserSetGroupRoleRequest

@implementation RPCUserSetGroupRoleRequest

@dynamic userId;
@dynamic groupId;
@dynamic membershipType;

typedef struct RPCUserSetGroupRoleRequest__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipRecord_MembershipType membershipType;
  NSString *userId;
  NSString *groupId;
} RPCUserSetGroupRoleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserSetGroupRoleRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserSetGroupRoleRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserSetGroupRoleRequest_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserSetGroupRoleRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "membershipType",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = RPCUserSetGroupRoleRequest_FieldNumber_MembershipType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserSetGroupRoleRequest__storage_, membershipType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserSetGroupRoleRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserSetGroupRoleRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserSetGroupRoleRequest_MembershipType_RawValue(RPCUserSetGroupRoleRequest *message) {
  GPBDescriptor *descriptor = [RPCUserSetGroupRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetGroupRoleRequest_FieldNumber_MembershipType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserSetGroupRoleRequest_MembershipType_RawValue(RPCUserSetGroupRoleRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserSetGroupRoleRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetGroupRoleRequest_FieldNumber_MembershipType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserSetGroupRoleResponse

@implementation RPCUserSetGroupRoleResponse

@dynamic error;

typedef struct RPCUserSetGroupRoleResponse__storage_ {
  uint32_t _has_storage_[1];
  UserSetGroupRoleResponse_ErrorType error;
} RPCUserSetGroupRoleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserSetGroupRoleResponse_ErrorType_EnumDescriptor,
        .number = RPCUserSetGroupRoleResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserSetGroupRoleResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserSetGroupRoleResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserSetGroupRoleResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserSetGroupRoleResponse_Error_RawValue(RPCUserSetGroupRoleResponse *message) {
  GPBDescriptor *descriptor = [RPCUserSetGroupRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetGroupRoleResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserSetGroupRoleResponse_Error_RawValue(RPCUserSetGroupRoleResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserSetGroupRoleResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserSetGroupRoleResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserUpdateVoiceStatusRequest

@implementation RPCUserUpdateVoiceStatusRequest

@dynamic userId;
@dynamic channelId;
@dynamic voiceStatus;

typedef struct RPCUserUpdateVoiceStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_VoiceStatus voiceStatus;
  NSString *userId;
  NSString *channelId;
} RPCUserUpdateVoiceStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdateVoiceStatusRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserUpdateVoiceStatusRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserUpdateVoiceStatusRequest_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserUpdateVoiceStatusRequest__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voiceStatus",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_VoiceStatus_EnumDescriptor,
        .number = RPCUserUpdateVoiceStatusRequest_FieldNumber_VoiceStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCUserUpdateVoiceStatusRequest__storage_, voiceStatus),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdateVoiceStatusRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserUpdateVoiceStatusRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserUpdateVoiceStatusRequest_VoiceStatus_RawValue(RPCUserUpdateVoiceStatusRequest *message) {
  GPBDescriptor *descriptor = [RPCUserUpdateVoiceStatusRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateVoiceStatusRequest_FieldNumber_VoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserUpdateVoiceStatusRequest_VoiceStatus_RawValue(RPCUserUpdateVoiceStatusRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserUpdateVoiceStatusRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserUpdateVoiceStatusRequest_FieldNumber_VoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserUpdateVoiceStatusResponse

@implementation RPCUserUpdateVoiceStatusResponse


typedef struct RPCUserUpdateVoiceStatusResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCUserUpdateVoiceStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserUpdateVoiceStatusResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCUserUpdateVoiceStatusResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserDeleteUserRequest

@implementation RPCUserDeleteUserRequest

@dynamic userId;

typedef struct RPCUserDeleteUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserDeleteUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserDeleteUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserDeleteUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserDeleteUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserDeleteUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserDeleteUserResponse

@implementation RPCUserDeleteUserResponse

@dynamic error;

typedef struct RPCUserDeleteUserResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCUserDeleteUserResponse_ErrorType error;
} RPCUserDeleteUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCUserDeleteUserResponse_ErrorType_EnumDescriptor,
        .number = RPCUserDeleteUserResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserDeleteUserResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserDeleteUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserDeleteUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserDeleteUserResponse_Error_RawValue(RPCUserDeleteUserResponse *message) {
  GPBDescriptor *descriptor = [RPCUserDeleteUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserDeleteUserResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserDeleteUserResponse_Error_RawValue(RPCUserDeleteUserResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserDeleteUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserDeleteUserResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RPCUserDeleteUserResponse_ErrorType

GPBEnumDescriptor *RPCUserDeleteUserResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000";
    static const int32_t values[] = {
        RPCUserDeleteUserResponse_ErrorType_None,
        RPCUserDeleteUserResponse_ErrorType_BadRequest,
        RPCUserDeleteUserResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RPCUserDeleteUserResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RPCUserDeleteUserResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RPCUserDeleteUserResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RPCUserDeleteUserResponse_ErrorType_None:
    case RPCUserDeleteUserResponse_ErrorType_BadRequest:
    case RPCUserDeleteUserResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RPCUserRemoveUserFromHubsRequest

@implementation RPCUserRemoveUserFromHubsRequest

@dynamic userId;

typedef struct RPCUserRemoveUserFromHubsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserRemoveUserFromHubsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserRemoveUserFromHubsRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserRemoveUserFromHubsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserRemoveUserFromHubsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserRemoveUserFromHubsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserRemoveUserFromHubsResponse

@implementation RPCUserRemoveUserFromHubsResponse

@dynamic error;

typedef struct RPCUserRemoveUserFromHubsResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCUserRemoveUserFromHubsResponse_ErrorType error;
} RPCUserRemoveUserFromHubsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCUserRemoveUserFromHubsResponse_ErrorType_EnumDescriptor,
        .number = RPCUserRemoveUserFromHubsResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserRemoveUserFromHubsResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserRemoveUserFromHubsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserRemoveUserFromHubsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserRemoveUserFromHubsResponse_Error_RawValue(RPCUserRemoveUserFromHubsResponse *message) {
  GPBDescriptor *descriptor = [RPCUserRemoveUserFromHubsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserRemoveUserFromHubsResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserRemoveUserFromHubsResponse_Error_RawValue(RPCUserRemoveUserFromHubsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserRemoveUserFromHubsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserRemoveUserFromHubsResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RPCUserRemoveUserFromHubsResponse_ErrorType

GPBEnumDescriptor *RPCUserRemoveUserFromHubsResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000";
    static const int32_t values[] = {
        RPCUserRemoveUserFromHubsResponse_ErrorType_None,
        RPCUserRemoveUserFromHubsResponse_ErrorType_BadRequest,
        RPCUserRemoveUserFromHubsResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RPCUserRemoveUserFromHubsResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RPCUserRemoveUserFromHubsResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RPCUserRemoveUserFromHubsResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RPCUserRemoveUserFromHubsResponse_ErrorType_None:
    case RPCUserRemoveUserFromHubsResponse_ErrorType_BadRequest:
    case RPCUserRemoveUserFromHubsResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RPCUserTransferOwnershipRequest

@implementation RPCUserTransferOwnershipRequest

@dynamic userId;
@dynamic targetUserAuthToken;

typedef struct RPCUserTransferOwnershipRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *targetUserAuthToken;
} RPCUserTransferOwnershipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserTransferOwnershipRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserTransferOwnershipRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetUserAuthToken",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserTransferOwnershipRequest_FieldNumber_TargetUserAuthToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserTransferOwnershipRequest__storage_, targetUserAuthToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserTransferOwnershipRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserTransferOwnershipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserTransferOwnershipResponse

@implementation RPCUserTransferOwnershipResponse

@dynamic error;

typedef struct RPCUserTransferOwnershipResponse__storage_ {
  uint32_t _has_storage_[1];
  UserTransferOwnershipResponse_ErrorType error;
} RPCUserTransferOwnershipResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserTransferOwnershipResponse_ErrorType_EnumDescriptor,
        .number = RPCUserTransferOwnershipResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserTransferOwnershipResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserTransferOwnershipResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserTransferOwnershipResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserTransferOwnershipResponse_Error_RawValue(RPCUserTransferOwnershipResponse *message) {
  GPBDescriptor *descriptor = [RPCUserTransferOwnershipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserTransferOwnershipResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserTransferOwnershipResponse_Error_RawValue(RPCUserTransferOwnershipResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserTransferOwnershipResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserTransferOwnershipResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserCheckBanStatusRequest

@implementation RPCUserCheckBanStatusRequest

@dynamic clientIp;

typedef struct RPCUserCheckBanStatusRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *clientIp;
} RPCUserCheckBanStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserCheckBanStatusRequest_FieldNumber_ClientIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserCheckBanStatusRequest__storage_, clientIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserCheckBanStatusRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserCheckBanStatusRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserCheckBanStatusResponse

@implementation RPCUserCheckBanStatusResponse

@dynamic error;
@dynamic isBanned;

typedef struct RPCUserCheckBanStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  UserCheckBanStatusResponse_ErrorType error;
} RPCUserCheckBanStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserCheckBanStatusResponse_ErrorType_EnumDescriptor,
        .number = RPCUserCheckBanStatusResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserCheckBanStatusResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isBanned",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserCheckBanStatusResponse_FieldNumber_IsBanned,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserCheckBanStatusResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserCheckBanStatusResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserCheckBanStatusResponse_Error_RawValue(RPCUserCheckBanStatusResponse *message) {
  GPBDescriptor *descriptor = [RPCUserCheckBanStatusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserCheckBanStatusResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserCheckBanStatusResponse_Error_RawValue(RPCUserCheckBanStatusResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserCheckBanStatusResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserCheckBanStatusResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserAddMutualContactsRequest

@implementation RPCUserAddMutualContactsRequest

@dynamic contactsArray, contactsArray_Count;

typedef struct RPCUserAddMutualContactsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *contactsArray;
} RPCUserAddMutualContactsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contactsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddMutualContactsRequestEntry),
        .number = RPCUserAddMutualContactsRequest_FieldNumber_ContactsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCUserAddMutualContactsRequest__storage_, contactsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserAddMutualContactsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserAddMutualContactsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddMutualContactsRequestEntry

@implementation AddMutualContactsRequestEntry

@dynamic firstUserId;
@dynamic secondUserId;
@dynamic mutual;

typedef struct AddMutualContactsRequestEntry__storage_ {
  uint32_t _has_storage_[1];
  NSString *firstUserId;
  NSString *secondUserId;
} AddMutualContactsRequestEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "firstUserId",
        .dataTypeSpecific.className = NULL,
        .number = AddMutualContactsRequestEntry_FieldNumber_FirstUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddMutualContactsRequestEntry__storage_, firstUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secondUserId",
        .dataTypeSpecific.className = NULL,
        .number = AddMutualContactsRequestEntry_FieldNumber_SecondUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddMutualContactsRequestEntry__storage_, secondUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mutual",
        .dataTypeSpecific.className = NULL,
        .number = AddMutualContactsRequestEntry_FieldNumber_Mutual,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddMutualContactsRequestEntry class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddMutualContactsRequestEntry__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserAddMutualContactsResponse

@implementation RPCUserAddMutualContactsResponse

@dynamic error;

typedef struct RPCUserAddMutualContactsResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCUserAddMutualContactsResponse_ErrorType error;
} RPCUserAddMutualContactsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCUserAddMutualContactsResponse_ErrorType_EnumDescriptor,
        .number = RPCUserAddMutualContactsResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserAddMutualContactsResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserAddMutualContactsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserAddMutualContactsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserAddMutualContactsResponse_Error_RawValue(RPCUserAddMutualContactsResponse *message) {
  GPBDescriptor *descriptor = [RPCUserAddMutualContactsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserAddMutualContactsResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserAddMutualContactsResponse_Error_RawValue(RPCUserAddMutualContactsResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserAddMutualContactsResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserAddMutualContactsResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RPCUserAddMutualContactsResponse_ErrorType

GPBEnumDescriptor *RPCUserAddMutualContactsResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000BadRequest\000UnknownError\000";
    static const int32_t values[] = {
        RPCUserAddMutualContactsResponse_ErrorType_None,
        RPCUserAddMutualContactsResponse_ErrorType_BadRequest,
        RPCUserAddMutualContactsResponse_ErrorType_UnknownError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RPCUserAddMutualContactsResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RPCUserAddMutualContactsResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RPCUserAddMutualContactsResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RPCUserAddMutualContactsResponse_ErrorType_None:
    case RPCUserAddMutualContactsResponse_ErrorType_BadRequest:
    case RPCUserAddMutualContactsResponse_ErrorType_UnknownError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RPCGroupRemoveUserRequest

@implementation RPCGroupRemoveUserRequest

@dynamic userId;
@dynamic groupId;
@dynamic type;

typedef struct RPCGroupRemoveUserRequest__storage_ {
  uint32_t _has_storage_[1];
  ProprietaryUserGroupRecord_Type type;
  NSString *userId;
  NSString *groupId;
} RPCGroupRemoveUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupRemoveUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupRemoveUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupRemoveUserRequest_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupRemoveUserRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ProprietaryUserGroupRecord_Type_EnumDescriptor,
        .number = RPCGroupRemoveUserRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupRemoveUserRequest__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupRemoveUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupRemoveUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupRemoveUserRequest_Type_RawValue(RPCGroupRemoveUserRequest *message) {
  GPBDescriptor *descriptor = [RPCGroupRemoveUserRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupRemoveUserRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupRemoveUserRequest_Type_RawValue(RPCGroupRemoveUserRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupRemoveUserRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupRemoveUserRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupRemoveUserResponse

@implementation RPCGroupRemoveUserResponse


typedef struct RPCGroupRemoveUserResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupRemoveUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupRemoveUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCGroupRemoveUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCAssociatedGroupUsersResponse

@implementation RPCAssociatedGroupUsersResponse

@dynamic usersArray, usersArray_Count;

typedef struct RPCAssociatedGroupUsersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} RPCAssociatedGroupUsersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RPCAssociatedGroupUsersResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCAssociatedGroupUsersResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCAssociatedGroupUsersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCAssociatedGroupUsersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCreateGroupRequest

@implementation RPCGroupCreateGroupRequest

@dynamic owner;
@dynamic name;
@dynamic description_p;
@dynamic titleImage;
@dynamic backgroundImage;
@dynamic skipChannelCreation;

typedef struct RPCGroupCreateGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *owner;
  NSString *name;
  NSString *description_p;
  NSString *titleImage;
  NSString *backgroundImage;
} RPCGroupCreateGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_Owner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupRequest__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupRequest__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_TitleImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_BackgroundImage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skipChannelCreation",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateGroupRequest_FieldNumber_SkipChannelCreation,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCreateGroupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCreateGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCreateGroupResponse

@implementation RPCGroupCreateGroupResponse

@dynamic error;
@dynamic hasGroup, group;

typedef struct RPCGroupCreateGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  CreateGroupErrorType error;
  Group *group;
} RPCGroupCreateGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = CreateGroupErrorType_EnumDescriptor,
        .number = RPCGroupCreateGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupCreateGroupResponse_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupCreateGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCreateGroupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCreateGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupCreateGroupResponse_Error_RawValue(RPCGroupCreateGroupResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupCreateGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupCreateGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupCreateGroupResponse_Error_RawValue(RPCGroupCreateGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupCreateGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupCreateGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupEditGroupRequest

@implementation RPCGroupEditGroupRequest

@dynamic id_p;
@dynamic hasOwner, owner;
@dynamic hasName, name;
@dynamic hasDescription_p, description_p;
@dynamic hasTitleImage, titleImage;
@dynamic hasBackgroundImage, backgroundImage;

typedef struct RPCGroupEditGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  OptionalString *owner;
  OptionalString *name;
  OptionalString *description_p;
  OptionalString *titleImage;
  OptionalString *backgroundImage;
} RPCGroupEditGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditGroupRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCGroupEditGroupRequest_FieldNumber_Owner,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCGroupEditGroupRequest_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCGroupEditGroupRequest_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCGroupEditGroupRequest_FieldNumber_TitleImage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = RPCGroupEditGroupRequest_FieldNumber_BackgroundImage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupRequest__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupEditGroupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupEditGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupEditGroupResponse

@implementation RPCGroupEditGroupResponse

@dynamic error;
@dynamic hasGroup, group;

typedef struct RPCGroupEditGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  CreateGroupErrorType error;
  Group *group;
} RPCGroupEditGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = CreateGroupErrorType_EnumDescriptor,
        .number = RPCGroupEditGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupEditGroupResponse_FieldNumber_Group,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupEditGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupEditGroupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupEditGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupEditGroupResponse_Error_RawValue(RPCGroupEditGroupResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupEditGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupEditGroupResponse_Error_RawValue(RPCGroupEditGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupEditGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupGetGroupRequest

@implementation RPCGroupGetGroupRequest

@dynamic groupId;
@dynamic fetchLinkedHubs;

typedef struct RPCGroupGetGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
} RPCGroupGetGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fetchLinkedHubs",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupRequest_FieldNumber_FetchLinkedHubs,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupResponse

@implementation RPCGroupGetGroupResponse

@dynamic hasGroup, group;
@dynamic linkedHubsArray, linkedHubsArray_Count;

typedef struct RPCGroupGetGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
  NSMutableArray *linkedHubsArray;
} RPCGroupGetGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupGetGroupResponse_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linkedHubsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Hub),
        .number = RPCGroupGetGroupResponse_FieldNumber_LinkedHubsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupResponse__storage_, linkedHubsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupsRequest

@implementation RPCGroupGetGroupsRequest


typedef struct RPCGroupGetGroupsRequest__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupGetGroupsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCGroupGetGroupsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupsResponse

@implementation RPCGroupGetGroupsResponse

@dynamic groupsArray, groupsArray_Count;

typedef struct RPCGroupGetGroupsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} RPCGroupGetGroupsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupGetGroupsResponse_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupsResponse__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupsForUserRequest

@implementation RPCGroupGetGroupsForUserRequest

@dynamic userId;

typedef struct RPCGroupGetGroupsForUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCGroupGetGroupsForUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupsForUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupsForUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupsForUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupsForUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupsForUserResponse

@implementation RPCGroupGetGroupsForUserResponse

@dynamic groupMembershipsArray, groupMembershipsArray_Count;

typedef struct RPCGroupGetGroupsForUserResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupMembershipsArray;
} RPCGroupGetGroupsForUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupMembershipsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMembership),
        .number = RPCGroupGetGroupsForUserResponse_FieldNumber_GroupMembershipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupsForUserResponse__storage_, groupMembershipsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupsForUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupsForUserResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000groupMemberships\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupAddGroupMemberRequest

@implementation RPCGroupAddGroupMemberRequest

@dynamic groupId;
@dynamic userId;
@dynamic type;

typedef struct RPCGroupAddGroupMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipRecord_MembershipType type;
  NSString *groupId;
  NSString *userId;
} RPCGroupAddGroupMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddGroupMemberRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMemberRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddGroupMemberRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMemberRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = RPCGroupAddGroupMemberRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMemberRequest__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddGroupMemberRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAddGroupMemberRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupAddGroupMemberRequest_Type_RawValue(RPCGroupAddGroupMemberRequest *message) {
  GPBDescriptor *descriptor = [RPCGroupAddGroupMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddGroupMemberRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupAddGroupMemberRequest_Type_RawValue(RPCGroupAddGroupMemberRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupAddGroupMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddGroupMemberRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupAddGroupMemberResponse

@implementation RPCGroupAddGroupMemberResponse


typedef struct RPCGroupAddGroupMemberResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupAddGroupMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddGroupMemberResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCGroupAddGroupMemberResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupAddGroupMembersRequest

@implementation RPCGroupAddGroupMembersRequest

@dynamic groupId;
@dynamic inviterId;
@dynamic inviteesArray, inviteesArray_Count;

typedef struct RPCGroupAddGroupMembersRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *inviterId;
  NSMutableArray *inviteesArray;
} RPCGroupAddGroupMembersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddGroupMembersRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMembersRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviterId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddGroupMembersRequest_FieldNumber_InviterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMembersRequest__storage_, inviterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PotentialGroupMember),
        .number = RPCGroupAddGroupMembersRequest_FieldNumber_InviteesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupAddGroupMembersRequest__storage_, inviteesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddGroupMembersRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAddGroupMembersRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupAddGroupMembersResponse

@implementation RPCGroupAddGroupMembersResponse


typedef struct RPCGroupAddGroupMembersResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupAddGroupMembersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddGroupMembersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCGroupAddGroupMembersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupRemoveGroupMemberRequest

@implementation RPCGroupRemoveGroupMemberRequest

@dynamic groupId;
@dynamic userId;

typedef struct RPCGroupRemoveGroupMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *userId;
} RPCGroupRemoveGroupMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupRemoveGroupMemberRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupRemoveGroupMemberRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupRemoveGroupMemberRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupRemoveGroupMemberRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupRemoveGroupMemberRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupRemoveGroupMemberRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupRemoveGroupMemberResponse

@implementation RPCGroupRemoveGroupMemberResponse


typedef struct RPCGroupRemoveGroupMemberResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupRemoveGroupMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupRemoveGroupMemberResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCGroupRemoveGroupMemberResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCheckGroupMembershipRequest

@implementation RPCGroupCheckGroupMembershipRequest

@dynamic groupId;
@dynamic userId;

typedef struct RPCGroupCheckGroupMembershipRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *userId;
} RPCGroupCheckGroupMembershipRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCheckGroupMembershipRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupCheckGroupMembershipRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCheckGroupMembershipRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupCheckGroupMembershipRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCheckGroupMembershipRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCheckGroupMembershipRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCheckGroupMembershipResponse

@implementation RPCGroupCheckGroupMembershipResponse

@dynamic isMember;

typedef struct RPCGroupCheckGroupMembershipResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCGroupCheckGroupMembershipResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMember",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCheckGroupMembershipResponse_FieldNumber_IsMember,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCheckGroupMembershipResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCheckGroupMembershipResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCreateInviteCodeRequest

@implementation RPCGroupCreateInviteCodeRequest

@dynamic groupId;
@dynamic inviterId;

typedef struct RPCGroupCreateInviteCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *inviterId;
} RPCGroupCreateInviteCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateInviteCodeRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupCreateInviteCodeRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviterId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateInviteCodeRequest_FieldNumber_InviterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupCreateInviteCodeRequest__storage_, inviterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCreateInviteCodeRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCreateInviteCodeRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupCreateInviteCodeResponse

@implementation RPCGroupCreateInviteCodeResponse

@dynamic inviteCode;

typedef struct RPCGroupCreateInviteCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} RPCGroupCreateInviteCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupCreateInviteCodeResponse_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupCreateInviteCodeResponse__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupCreateInviteCodeResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupCreateInviteCodeResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetInviteCodeInfoRequest

@implementation RPCGroupGetInviteCodeInfoRequest

@dynamic inviteCode;

typedef struct RPCGroupGetInviteCodeInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
} RPCGroupGetInviteCodeInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetInviteCodeInfoRequest_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetInviteCodeInfoRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetInviteCodeInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetInviteCodeInfoRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetInviteCodeInfoResponse

@implementation RPCGroupGetInviteCodeInfoResponse

@dynamic hasGroup, group;

typedef struct RPCGroupGetInviteCodeInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
} RPCGroupGetInviteCodeInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupGetInviteCodeInfoResponse_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetInviteCodeInfoResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetInviteCodeInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetInviteCodeInfoResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupAcceptInviteRequest

@implementation RPCGroupAcceptInviteRequest

@dynamic inviteCode;
@dynamic userId;

typedef struct RPCGroupAcceptInviteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteCode;
  NSString *userId;
} RPCGroupAcceptInviteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAcceptInviteRequest_FieldNumber_InviteCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupAcceptInviteRequest__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAcceptInviteRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupAcceptInviteRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAcceptInviteRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAcceptInviteRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupAcceptInviteResponse

@implementation RPCGroupAcceptInviteResponse

@dynamic success;
@dynamic hasGroup, group;

typedef struct RPCGroupAcceptInviteResponse__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
} RPCGroupAcceptInviteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAcceptInviteResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCGroupAcceptInviteResponse_FieldNumber_Group,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupAcceptInviteResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAcceptInviteResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAcceptInviteResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupTokenRequest

@implementation RPCGroupGetGroupTokenRequest

@dynamic userId;
@dynamic groupId;

typedef struct RPCGroupGetGroupTokenRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *groupId;
} RPCGroupGetGroupTokenRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupTokenRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupTokenRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupTokenRequest_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupTokenRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupTokenRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupTokenRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetGroupTokenResponse

@implementation RPCGroupGetGroupTokenResponse

@dynamic error;
@dynamic token;

typedef struct RPCGroupGetGroupTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupGetGroupTokenResponse_ErrorType error;
  NSString *token;
} RPCGroupGetGroupTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupGetGroupTokenResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupGetGroupTokenResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupTokenResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetGroupTokenResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupGetGroupTokenResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetGroupTokenResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetGroupTokenResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupGetGroupTokenResponse_Error_RawValue(RPCGroupGetGroupTokenResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupGetGroupTokenResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupGetGroupTokenResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupGetGroupTokenResponse_Error_RawValue(RPCGroupGetGroupTokenResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupGetGroupTokenResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupGetGroupTokenResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupAddMemberRequest

@implementation RPCGroupAddMemberRequest

@dynamic identifierOneOfCase;
@dynamic groupId;
@dynamic inviterId;
@dynamic userId;
@dynamic email;
@dynamic type;
@dynamic fetchExisting;
@dynamic fetchPending;

typedef struct RPCGroupAddMemberRequest__storage_ {
  uint32_t _has_storage_[2];
  MembershipEntry_MembershipType type;
  NSString *groupId;
  NSString *inviterId;
  NSString *userId;
  NSString *email;
} RPCGroupAddMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviterId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_InviterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberRequest__storage_, inviterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_UserId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_Email,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = MembershipEntry_MembershipType_EnumDescriptor,
        .number = RPCGroupAddMemberRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberRequest__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fetchExisting",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_FetchExisting,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fetchPending",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupAddMemberRequest_FieldNumber_FetchPending,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddMemberRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAddMemberRequest__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupAddMemberRequest_Type_RawValue(RPCGroupAddMemberRequest *message) {
  GPBDescriptor *descriptor = [RPCGroupAddMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddMemberRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupAddMemberRequest_Type_RawValue(RPCGroupAddMemberRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupAddMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddMemberRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void RPCGroupAddMemberRequest_ClearIdentifierOneOfCase(RPCGroupAddMemberRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - RPCGroupAddMemberResponse

@implementation RPCGroupAddMemberResponse

@dynamic error;
@dynamic existingUsersArray, existingUsersArray_Count;
@dynamic pendingUsersArray, pendingUsersArray_Count;

typedef struct RPCGroupAddMemberResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCHubAddMemberResponse_ErrorType error;
  NSMutableArray *existingUsersArray;
  NSMutableArray *pendingUsersArray;
} RPCGroupAddMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCHubAddMemberResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupAddMemberResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "existingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupAddMemberResponse_FieldNumber_ExistingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberResponse__storage_, existingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupAddMemberResponse_FieldNumber_PendingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupAddMemberResponse__storage_, pendingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupAddMemberResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupAddMemberResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupAddMemberResponse_Error_RawValue(RPCGroupAddMemberResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupAddMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddMemberResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupAddMemberResponse_Error_RawValue(RPCGroupAddMemberResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupAddMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupAddMemberResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupGetMembersRequest

@implementation RPCGroupGetMembersRequest

@dynamic groupId;
@dynamic userId;
@dynamic fetchExisting;
@dynamic fetchPending;

typedef struct RPCGroupGetMembersRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *userId;
} RPCGroupGetMembersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetMembersRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetMembersRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetMembersRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupGetMembersRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fetchExisting",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetMembersRequest_FieldNumber_FetchExisting,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fetchPending",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupGetMembersRequest_FieldNumber_FetchPending,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetMembersRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetMembersRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupGetMembersResponse

@implementation RPCGroupGetMembersResponse

@dynamic error;
@dynamic existingUsersArray, existingUsersArray_Count;
@dynamic pendingUsersArray, pendingUsersArray_Count;

typedef struct RPCGroupGetMembersResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCHubGetMembersResponse_ErrorType error;
  NSMutableArray *existingUsersArray;
  NSMutableArray *pendingUsersArray;
} RPCGroupGetMembersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCHubGetMembersResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupGetMembersResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupGetMembersResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "existingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupGetMembersResponse_FieldNumber_ExistingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupGetMembersResponse__storage_, existingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupGetMembersResponse_FieldNumber_PendingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupGetMembersResponse__storage_, pendingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupGetMembersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupGetMembersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupGetMembersResponse_Error_RawValue(RPCGroupGetMembersResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupGetMembersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupGetMembersResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupGetMembersResponse_Error_RawValue(RPCGroupGetMembersResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupGetMembersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupGetMembersResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupSendInviteRequest

@implementation RPCGroupSendInviteRequest

@dynamic groupId;
@dynamic senderId;
@dynamic userId;
@dynamic email;

typedef struct RPCGroupSendInviteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *senderId;
  NSString *userId;
  NSString *email;
} RPCGroupSendInviteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupSendInviteRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupSendInviteRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupSendInviteRequest_FieldNumber_SenderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupSendInviteRequest__storage_, senderId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupSendInviteRequest_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupSendInviteRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupSendInviteRequest_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCGroupSendInviteRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupSendInviteRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupSendInviteRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupSendInviteResponse

@implementation RPCGroupSendInviteResponse

@dynamic error;

typedef struct RPCGroupSendInviteResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCHubSendInviteResponse_ErrorType error;
} RPCGroupSendInviteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCHubSendInviteResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupSendInviteResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupSendInviteResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupSendInviteResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupSendInviteResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupSendInviteResponse_Error_RawValue(RPCGroupSendInviteResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupSendInviteResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupSendInviteResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupSendInviteResponse_Error_RawValue(RPCGroupSendInviteResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupSendInviteResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupSendInviteResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupEditMemberRequest

@implementation RPCGroupEditMemberRequest

@dynamic groupId;
@dynamic editerId;
@dynamic userId;
@dynamic email;
@dynamic type;
@dynamic fetchExisting;
@dynamic fetchPending;

typedef struct RPCGroupEditMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  MembershipEntry_MembershipType type;
  NSString *groupId;
  NSString *editerId;
  NSString *userId;
  NSString *email;
} RPCGroupEditMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "editerId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_EditerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberRequest__storage_, editerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberRequest__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = MembershipEntry_MembershipType_EnumDescriptor,
        .number = RPCGroupEditMemberRequest_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberRequest__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fetchExisting",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_FetchExisting,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fetchPending",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupEditMemberRequest_FieldNumber_FetchPending,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupEditMemberRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupEditMemberRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupEditMemberRequest_Type_RawValue(RPCGroupEditMemberRequest *message) {
  GPBDescriptor *descriptor = [RPCGroupEditMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditMemberRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupEditMemberRequest_Type_RawValue(RPCGroupEditMemberRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupEditMemberRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditMemberRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupEditMemberResponse

@implementation RPCGroupEditMemberResponse

@dynamic error;
@dynamic existingUsersArray, existingUsersArray_Count;
@dynamic pendingUsersArray, pendingUsersArray_Count;

typedef struct RPCGroupEditMemberResponse__storage_ {
  uint32_t _has_storage_[1];
  RPCHubEditMemberResponse_ErrorType error;
  NSMutableArray *existingUsersArray;
  NSMutableArray *pendingUsersArray;
} RPCGroupEditMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = RPCHubEditMemberResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupEditMemberResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "existingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupEditMemberResponse_FieldNumber_ExistingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberResponse__storage_, existingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pendingUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MembershipEntry),
        .number = RPCGroupEditMemberResponse_FieldNumber_PendingUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCGroupEditMemberResponse__storage_, pendingUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupEditMemberResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupEditMemberResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupEditMemberResponse_Error_RawValue(RPCGroupEditMemberResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupEditMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditMemberResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupEditMemberResponse_Error_RawValue(RPCGroupEditMemberResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupEditMemberResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupEditMemberResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupJoinGroupRequest

@implementation RPCGroupJoinGroupRequest

@dynamic groupId;
@dynamic userId;
@dynamic code;

typedef struct RPCGroupJoinGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *userId;
  NSString *code;
} RPCGroupJoinGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupJoinGroupRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupJoinGroupRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupJoinGroupRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupJoinGroupRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupJoinGroupRequest_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCGroupJoinGroupRequest__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupJoinGroupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupJoinGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupJoinGroupResponse

@implementation RPCGroupJoinGroupResponse

@dynamic error;

typedef struct RPCGroupJoinGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupJoinResponse_ErrorType error;
} RPCGroupJoinGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupJoinResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupJoinGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupJoinGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupJoinGroupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupJoinGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupJoinGroupResponse_Error_RawValue(RPCGroupJoinGroupResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupJoinGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupJoinGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupJoinGroupResponse_Error_RawValue(RPCGroupJoinGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupJoinGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupJoinGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCGroupLeaveGroupRequest

@implementation RPCGroupLeaveGroupRequest

@dynamic groupId;
@dynamic userId;

typedef struct RPCGroupLeaveGroupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *userId;
} RPCGroupLeaveGroupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupLeaveGroupRequest_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupLeaveGroupRequest__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCGroupLeaveGroupRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCGroupLeaveGroupRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupLeaveGroupRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupLeaveGroupRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCGroupLeaveGroupResponse

@implementation RPCGroupLeaveGroupResponse

@dynamic error;

typedef struct RPCGroupLeaveGroupResponse__storage_ {
  uint32_t _has_storage_[1];
  GroupLeaveResponse_ErrorType error;
} RPCGroupLeaveGroupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = GroupLeaveResponse_ErrorType_EnumDescriptor,
        .number = RPCGroupLeaveGroupResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCGroupLeaveGroupResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCGroupLeaveGroupResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCGroupLeaveGroupResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCGroupLeaveGroupResponse_Error_RawValue(RPCGroupLeaveGroupResponse *message) {
  GPBDescriptor *descriptor = [RPCGroupLeaveGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupLeaveGroupResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCGroupLeaveGroupResponse_Error_RawValue(RPCGroupLeaveGroupResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCGroupLeaveGroupResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCGroupLeaveGroupResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCPrefsGetPrefRequest

@implementation RPCPrefsGetPrefRequest

@dynamic userId;
@dynamic domain;
@dynamic keypath;

typedef struct RPCPrefsGetPrefRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *domain;
  NSString *keypath;
} RPCPrefsGetPrefRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefRequest_FieldNumber_Domain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefRequest__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keypath",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefRequest_FieldNumber_Keypath,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefRequest__storage_, keypath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsGetPrefRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsGetPrefRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsGetPrefResponse

@implementation RPCPrefsGetPrefResponse

@dynamic hasPref, pref;

typedef struct RPCPrefsGetPrefResponse__storage_ {
  uint32_t _has_storage_[1];
  Pref *pref;
} RPCPrefsGetPrefResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pref",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = RPCPrefsGetPrefResponse_FieldNumber_Pref,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefResponse__storage_, pref),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsGetPrefResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsGetPrefResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsGetPrefsRequest

@implementation RPCPrefsGetPrefsRequest

@dynamic userId;
@dynamic domain;
@dynamic keypathPrefix;

typedef struct RPCPrefsGetPrefsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *domain;
  NSString *keypathPrefix;
} RPCPrefsGetPrefsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefsRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefsRequest_FieldNumber_Domain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefsRequest__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keypathPrefix",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsGetPrefsRequest_FieldNumber_KeypathPrefix,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefsRequest__storage_, keypathPrefix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsGetPrefsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsGetPrefsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsGetPrefsResponse

@implementation RPCPrefsGetPrefsResponse

@dynamic prefsArray, prefsArray_Count;

typedef struct RPCPrefsGetPrefsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *prefsArray;
} RPCPrefsGetPrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prefsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = RPCPrefsGetPrefsResponse_FieldNumber_PrefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCPrefsGetPrefsResponse__storage_, prefsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsGetPrefsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsGetPrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsSetPrefsRequest

@implementation RPCPrefsSetPrefsRequest

@dynamic userId;
@dynamic prefsArray, prefsArray_Count;

typedef struct RPCPrefsSetPrefsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSMutableArray *prefsArray;
} RPCPrefsSetPrefsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsSetPrefsRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCPrefsSetPrefsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prefsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Pref),
        .number = RPCPrefsSetPrefsRequest_FieldNumber_PrefsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCPrefsSetPrefsRequest__storage_, prefsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsSetPrefsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsSetPrefsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsSetPrefsResponse

@implementation RPCPrefsSetPrefsResponse


typedef struct RPCPrefsSetPrefsResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCPrefsSetPrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsSetPrefsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCPrefsSetPrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsDeletePrefsRequest

@implementation RPCPrefsDeletePrefsRequest

@dynamic userId;
@dynamic domain;
@dynamic keypathPrefix;

typedef struct RPCPrefsDeletePrefsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *domain;
  NSString *keypathPrefix;
} RPCPrefsDeletePrefsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsDeletePrefsRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCPrefsDeletePrefsRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsDeletePrefsRequest_FieldNumber_Domain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCPrefsDeletePrefsRequest__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keypathPrefix",
        .dataTypeSpecific.className = NULL,
        .number = RPCPrefsDeletePrefsRequest_FieldNumber_KeypathPrefix,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RPCPrefsDeletePrefsRequest__storage_, keypathPrefix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsDeletePrefsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCPrefsDeletePrefsRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCPrefsDeletePrefsResponse

@implementation RPCPrefsDeletePrefsResponse


typedef struct RPCPrefsDeletePrefsResponse__storage_ {
  uint32_t _has_storage_[1];
} RPCPrefsDeletePrefsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCPrefsDeletePrefsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RPCPrefsDeletePrefsResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCSearchSearchRequest

@implementation RPCSearchSearchRequest

@dynamic searchTerm;
@dynamic limit;
@dynamic searchUsers;
@dynamic searchChannels;
@dynamic searchGroups;
@dynamic searchGames;
@dynamic searchTags;

typedef struct RPCSearchSearchRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t limit;
  NSString *searchTerm;
} RPCSearchSearchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchTerm",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchTerm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCSearchSearchRequest__storage_, searchTerm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCSearchSearchRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "searchUsers",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchUsers,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchChannels",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchChannels,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchGroups",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchGroups,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchGames",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchGames,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchTags",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchRequest_FieldNumber_SearchTags,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCSearchSearchRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCSearchSearchRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCSearchSearchResponse

@implementation RPCSearchSearchResponse

@dynamic usersArray, usersArray_Count;
@dynamic channelsArray, channelsArray_Count;
@dynamic groupsArray, groupsArray_Count;
@dynamic gamesArray, gamesArray_Count;
@dynamic tagsArray, tagsArray_Count;

typedef struct RPCSearchSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
  NSMutableArray *channelsArray;
  NSMutableArray *groupsArray;
  NSMutableArray *gamesArray;
  NSMutableArray *tagsArray;
} RPCSearchSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = RPCSearchSearchResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCSearchSearchResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = RPCSearchSearchResponse_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCSearchSearchResponse__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = RPCSearchSearchResponse_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCSearchSearchResponse__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = RPCSearchSearchResponse_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCSearchSearchResponse__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = RPCSearchSearchResponse_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCSearchSearchResponse__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCSearchSearchResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCSearchSearchResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserEditBlockedUserRequest

@implementation RPCUserEditBlockedUserRequest

@dynamic userId;
@dynamic blockedUserId;
@dynamic remove;

typedef struct RPCUserEditBlockedUserRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *blockedUserId;
} RPCUserEditBlockedUserRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserEditBlockedUserRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserEditBlockedUserRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockedUserId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserEditBlockedUserRequest_FieldNumber_BlockedUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RPCUserEditBlockedUserRequest__storage_, blockedUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remove",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserEditBlockedUserRequest_FieldNumber_Remove,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserEditBlockedUserRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserEditBlockedUserRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserEditBlockedUserResponse

@implementation RPCUserEditBlockedUserResponse

@dynamic error;

typedef struct RPCUserEditBlockedUserResponse__storage_ {
  uint32_t _has_storage_[1];
  UserEditBlockedUserResponse_ErrorType error;
} RPCUserEditBlockedUserResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserEditBlockedUserResponse_ErrorType_EnumDescriptor,
        .number = RPCUserEditBlockedUserResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserEditBlockedUserResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserEditBlockedUserResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserEditBlockedUserResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserEditBlockedUserResponse_Error_RawValue(RPCUserEditBlockedUserResponse *message) {
  GPBDescriptor *descriptor = [RPCUserEditBlockedUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserEditBlockedUserResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserEditBlockedUserResponse_Error_RawValue(RPCUserEditBlockedUserResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserEditBlockedUserResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserEditBlockedUserResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RPCUserGetBlockedUsersRequest

@implementation RPCUserGetBlockedUsersRequest

@dynamic userId;

typedef struct RPCUserGetBlockedUsersRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} RPCUserGetBlockedUsersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = RPCUserGetBlockedUsersRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetBlockedUsersRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetBlockedUsersRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetBlockedUsersRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RPCUserGetBlockedUsersResponse

@implementation RPCUserGetBlockedUsersResponse

@dynamic error;
@dynamic usersArray, usersArray_Count;

typedef struct RPCUserGetBlockedUsersResponse__storage_ {
  uint32_t _has_storage_[1];
  UserGetBlockedUsersResponse_ErrorType error;
  NSMutableArray *usersArray;
} RPCUserGetBlockedUsersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = UserGetBlockedUsersResponse_ErrorType_EnumDescriptor,
        .number = RPCUserGetBlockedUsersResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RPCUserGetBlockedUsersResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = RPCUserGetBlockedUsersResponse_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RPCUserGetBlockedUsersResponse__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RPCUserGetBlockedUsersResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RPCUserGetBlockedUsersResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RPCUserGetBlockedUsersResponse_Error_RawValue(RPCUserGetBlockedUsersResponse *message) {
  GPBDescriptor *descriptor = [RPCUserGetBlockedUsersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetBlockedUsersResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetRPCUserGetBlockedUsersResponse_Error_RawValue(RPCUserGetBlockedUsersResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RPCUserGetBlockedUsersResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RPCUserGetBlockedUsersResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
