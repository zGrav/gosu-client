// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eventlog.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Eventlog.pbobjc.h"
 #import "Profile.pbobjc.h"
 #import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - EventlogRoot

@implementation EventlogRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[ProfileRoot extensionRegistry]];
    [registry addExtensions:[MessageRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - EventlogRoot_FileDescriptor

static GPBFileDescriptor *EventlogRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - EventLogGetLogEntriesResponse

@implementation EventLogGetLogEntriesResponse

@dynamic error;
@dynamic logEntriesArray, logEntriesArray_Count;

typedef struct EventLogGetLogEntriesResponse__storage_ {
  uint32_t _has_storage_[1];
  EventLogGetLogEntriesResponse_ErrorType error;
  NSMutableArray *logEntriesArray;
} EventLogGetLogEntriesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.enumDescFunc = EventLogGetLogEntriesResponse_ErrorType_EnumDescriptor,
        .number = EventLogGetLogEntriesResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EventLogGetLogEntriesResponse__storage_, error),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "logEntriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LogEntry),
        .number = EventLogGetLogEntriesResponse_FieldNumber_LogEntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EventLogGetLogEntriesResponse__storage_, logEntriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EventLogGetLogEntriesResponse class]
                                     rootClass:[EventlogRoot class]
                                          file:EventlogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EventLogGetLogEntriesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t EventLogGetLogEntriesResponse_Error_RawValue(EventLogGetLogEntriesResponse *message) {
  GPBDescriptor *descriptor = [EventLogGetLogEntriesResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EventLogGetLogEntriesResponse_FieldNumber_Error];
  return GPBGetMessageInt32Field(message, field);
}

void SetEventLogGetLogEntriesResponse_Error_RawValue(EventLogGetLogEntriesResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [EventLogGetLogEntriesResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:EventLogGetLogEntriesResponse_FieldNumber_Error];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum EventLogGetLogEntriesResponse_ErrorType

GPBEnumDescriptor *EventLogGetLogEntriesResponse_ErrorType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000UnknownError\000Forbidden\000BadRequest\000";
    static const int32_t values[] = {
        EventLogGetLogEntriesResponse_ErrorType_None,
        EventLogGetLogEntriesResponse_ErrorType_UnknownError,
        EventLogGetLogEntriesResponse_ErrorType_Forbidden,
        EventLogGetLogEntriesResponse_ErrorType_BadRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EventLogGetLogEntriesResponse_ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EventLogGetLogEntriesResponse_ErrorType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EventLogGetLogEntriesResponse_ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EventLogGetLogEntriesResponse_ErrorType_None:
    case EventLogGetLogEntriesResponse_ErrorType_UnknownError:
    case EventLogGetLogEntriesResponse_ErrorType_Forbidden:
    case EventLogGetLogEntriesResponse_ErrorType_BadRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - LogEntryEvent

@implementation LogEntryEvent

@dynamic timestamp;
@dynamic channelId;
@dynamic communityId;
@dynamic sourceUserId;
@dynamic targetId;
@dynamic hasTargetMessage, targetMessage;
@dynamic targetType;
@dynamic action;
@dynamic actionType;
@dynamic reason;
@dynamic description_p;

typedef struct LogEntryEvent__storage_ {
  uint32_t _has_storage_[1];
  LogEntry_TargetType targetType;
  LogEntry_ActionType actionType;
  NSString *channelId;
  NSString *communityId;
  NSString *sourceUserId;
  NSString *targetId;
  WebsocketMessage *targetMessage;
  NSString *action;
  NSString *reason;
  NSString *description_p;
  int64_t timestamp;
} LogEntryEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "communityId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_CommunityId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, communityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceUserId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_SourceUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, sourceUserId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = LogEntryEvent_FieldNumber_TargetMessage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, targetMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = LogEntry_TargetType_EnumDescriptor,
        .number = LogEntryEvent_FieldNumber_TargetType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, targetType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_Action,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actionType",
        .dataTypeSpecific.enumDescFunc = LogEntry_ActionType_EnumDescriptor,
        .number = LogEntryEvent_FieldNumber_ActionType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, actionType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_Reason,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = LogEntryEvent_FieldNumber_Description_p,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LogEntryEvent__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogEntryEvent class]
                                     rootClass:[EventlogRoot class]
                                          file:EventlogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogEntryEvent__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LogEntryEvent_TargetType_RawValue(LogEntryEvent *message) {
  GPBDescriptor *descriptor = [LogEntryEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntryEvent_FieldNumber_TargetType];
  return GPBGetMessageInt32Field(message, field);
}

void SetLogEntryEvent_TargetType_RawValue(LogEntryEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [LogEntryEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntryEvent_FieldNumber_TargetType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t LogEntryEvent_ActionType_RawValue(LogEntryEvent *message) {
  GPBDescriptor *descriptor = [LogEntryEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntryEvent_FieldNumber_ActionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetLogEntryEvent_ActionType_RawValue(LogEntryEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [LogEntryEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntryEvent_FieldNumber_ActionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - LogEntry

@implementation LogEntry

@dynamic targetOneOfCase;
@dynamic id_p;
@dynamic timestamp;
@dynamic channelId;
@dynamic communityId;
@dynamic hasSourceUser, sourceUser;
@dynamic targetUser;
@dynamic targetMessage;
@dynamic targetType;
@dynamic action;
@dynamic actionType;
@dynamic reason;
@dynamic description_p;
@dynamic contextArray, contextArray_Count;

typedef struct LogEntry__storage_ {
  uint32_t _has_storage_[2];
  LogEntry_TargetType targetType;
  LogEntry_ActionType actionType;
  NSString *id_p;
  NSString *channelId;
  NSString *communityId;
  ChatUser *sourceUser;
  ChatUser *targetUser;
  WebsocketMessage *targetMessage;
  NSString *action;
  NSString *reason;
  NSString *description_p;
  NSMutableArray *contextArray;
  int64_t timestamp;
} LogEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogEntry__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogEntry__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LogEntry__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "communityId",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_CommunityId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LogEntry__storage_, communityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceUser",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = LogEntry_FieldNumber_SourceUser,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LogEntry__storage_, sourceUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetUser",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = LogEntry_FieldNumber_TargetUser,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntry__storage_, targetUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = LogEntry_FieldNumber_TargetMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(LogEntry__storage_, targetMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetType",
        .dataTypeSpecific.enumDescFunc = LogEntry_TargetType_EnumDescriptor,
        .number = LogEntry_FieldNumber_TargetType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LogEntry__storage_, targetType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_Action,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LogEntry__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actionType",
        .dataTypeSpecific.enumDescFunc = LogEntry_ActionType_EnumDescriptor,
        .number = LogEntry_FieldNumber_ActionType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LogEntry__storage_, actionType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_Reason,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LogEntry__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = LogEntry_FieldNumber_Description_p,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LogEntry__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contextArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = LogEntry_FieldNumber_ContextArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LogEntry__storage_, contextArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogEntry class]
                                     rootClass:[EventlogRoot class]
                                          file:EventlogRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogEntry__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "target",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LogEntry_TargetType_RawValue(LogEntry *message) {
  GPBDescriptor *descriptor = [LogEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntry_FieldNumber_TargetType];
  return GPBGetMessageInt32Field(message, field);
}

void SetLogEntry_TargetType_RawValue(LogEntry *message, int32_t value) {
  GPBDescriptor *descriptor = [LogEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntry_FieldNumber_TargetType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t LogEntry_ActionType_RawValue(LogEntry *message) {
  GPBDescriptor *descriptor = [LogEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntry_FieldNumber_ActionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetLogEntry_ActionType_RawValue(LogEntry *message, int32_t value) {
  GPBDescriptor *descriptor = [LogEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LogEntry_FieldNumber_ActionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void LogEntry_ClearTargetOneOfCase(LogEntry *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum LogEntry_TargetType

GPBEnumDescriptor *LogEntry_TargetType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Notarget\000User\000Message\000";
    static const int32_t values[] = {
        LogEntry_TargetType_Notarget,
        LogEntry_TargetType_User,
        LogEntry_TargetType_Message,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LogEntry_TargetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LogEntry_TargetType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LogEntry_TargetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case LogEntry_TargetType_Notarget:
    case LogEntry_TargetType_User:
    case LogEntry_TargetType_Message:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum LogEntry_ActionType

GPBEnumDescriptor *LogEntry_ActionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Other\000KickBan\000MessageDelete\000MessagePurge"
        "\000";
    static const int32_t values[] = {
        LogEntry_ActionType_Other,
        LogEntry_ActionType_KickBan,
        LogEntry_ActionType_MessageDelete,
        LogEntry_ActionType_MessagePurge,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LogEntry_ActionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LogEntry_ActionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LogEntry_ActionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case LogEntry_ActionType_Other:
    case LogEntry_ActionType_KickBan:
    case LogEntry_ActionType_MessageDelete:
    case LogEntry_ActionType_MessagePurge:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
