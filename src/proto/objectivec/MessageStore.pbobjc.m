// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message_store.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "MessageStore.pbobjc.h"
 #import "Api.pbobjc.h"
 #import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MessageStoreRoot

@implementation MessageStoreRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[ApiRoot extensionRegistry]];
    [registry addExtensions:[MessageRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MessageStoreRoot_FileDescriptor

static GPBFileDescriptor *MessageStoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GetMessageRequest

@implementation GetMessageRequest

@dynamic messageId;

typedef struct GetMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *messageId;
} GetMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = GetMessageRequest_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMessageRequest__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMessageRequest class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMessageRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMessageResponse

@implementation GetMessageResponse

@dynamic hasMessage, message;
@dynamic success;
@dynamic hasError, error;

typedef struct GetMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  WebsocketMessage *message;
  APIError *error;
} GetMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = GetMessageResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMessageResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetMessageResponse_FieldNumber_Success,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = GetMessageResponse_FieldNumber_Error,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetMessageResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMessageResponse class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMessageResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMessagesRequest

@implementation GetMessagesRequest

@dynamic channelId;
@dynamic start;
@dynamic end;
@dynamic sortAscending;
@dynamic includeDeleted;
@dynamic limit;

typedef struct GetMessagesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelId;
  NSString *start;
  NSString *end;
  int64_t limit;
} GetMessagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMessagesRequest__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMessagesRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetMessagesRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sortAscending",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_SortAscending,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "includeDeleted",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_IncludeDeleted,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesRequest_FieldNumber_Limit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetMessagesRequest__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMessagesRequest class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMessagesRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMessagesResponse

@implementation GetMessagesResponse

@dynamic messagesArray, messagesArray_Count;
@dynamic success;
@dynamic hasError, error;

typedef struct GetMessagesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
  APIError *error;
} GetMessagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = GetMessagesResponse_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMessagesResponse__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = GetMessagesResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = GetMessagesResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetMessagesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMessagesResponse class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMessagesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IndexMessagesRequest

@implementation IndexMessagesRequest

@dynamic messagesArray, messagesArray_Count;

typedef struct IndexMessagesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
} IndexMessagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = IndexMessagesRequest_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(IndexMessagesRequest__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IndexMessagesRequest class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IndexMessagesRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IndexMessagesResponse

@implementation IndexMessagesResponse

@dynamic success;
@dynamic hasError, error;

typedef struct IndexMessagesResponse__storage_ {
  uint32_t _has_storage_[1];
  APIError *error;
} IndexMessagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = IndexMessagesResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = IndexMessagesResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IndexMessagesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IndexMessagesResponse class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IndexMessagesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteMessagesRequest

@implementation DeleteMessagesRequest

@dynamic messageIdsArray, messageIdsArray_Count;
@dynamic userId;

typedef struct DeleteMessagesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messageIdsArray;
  NSString *userId;
} DeleteMessagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessagesRequest_FieldNumber_MessageIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeleteMessagesRequest__storage_, messageIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessagesRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeleteMessagesRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteMessagesRequest class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteMessagesRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteMessagesResponse

@implementation DeleteMessagesResponse

@dynamic success;
@dynamic hasError, error;

typedef struct DeleteMessagesResponse__storage_ {
  uint32_t _has_storage_[1];
  APIError *error;
} DeleteMessagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessagesResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = DeleteMessagesResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeleteMessagesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteMessagesResponse class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteMessagesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteMessageBatchRequest

@implementation DeleteMessageBatchRequest

@dynamic channelId;
@dynamic start;
@dynamic end;
@dynamic userId;
@dynamic deleterId;

typedef struct DeleteMessageBatchRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelId;
  NSString *start;
  NSString *end;
  NSString *userId;
  NSString *deleterId;
} DeleteMessageBatchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchRequest_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeleteMessageBatchRequest__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchRequest_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeleteMessageBatchRequest__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchRequest_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeleteMessageBatchRequest__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchRequest_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeleteMessageBatchRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deleterId",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchRequest_FieldNumber_DeleterId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeleteMessageBatchRequest__storage_, deleterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteMessageBatchRequest class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteMessageBatchRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteMessageBatchResponse

@implementation DeleteMessageBatchResponse

@dynamic success;
@dynamic hasError, error;

typedef struct DeleteMessageBatchResponse__storage_ {
  uint32_t _has_storage_[1];
  APIError *error;
} DeleteMessageBatchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = DeleteMessageBatchResponse_FieldNumber_Success,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(APIError),
        .number = DeleteMessageBatchResponse_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeleteMessageBatchResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteMessageBatchResponse class]
                                     rootClass:[MessageStoreRoot class]
                                          file:MessageStoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteMessageBatchResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
