// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: profile.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Profile.pbobjc.h"
 #import "Optional.pbobjc.h"
 #import "HubBase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ProfileRoot

@implementation ProfileRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[OptionalRoot extensionRegistry]];
    [registry addExtensions:[HubBaseRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - ProfileRoot_FileDescriptor

static GPBFileDescriptor *ProfileRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum GroupMembershipTypeV1

GPBEnumDescriptor *GroupMembershipTypeV1_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Member\000Guest\000";
    static const int32_t values[] = {
        GroupMembershipTypeV1_Unknown,
        GroupMembershipTypeV1_Member,
        GroupMembershipTypeV1_Guest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupMembershipTypeV1)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupMembershipTypeV1_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupMembershipTypeV1_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupMembershipTypeV1_Unknown:
    case GroupMembershipTypeV1_Member:
    case GroupMembershipTypeV1_Guest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - User

@implementation User

@dynamic id_p;
@dynamic login;
@dynamic password;
@dynamic email;
@dynamic displayName;
@dynamic avatarImage;
@dynamic channelIdsArray, channelIdsArray_Count;
@dynamic channelsArray, channelsArray_Count;
@dynamic emailConfirmed;
@dynamic status;
@dynamic termsOfService;
@dynamic newsletter;
@dynamic titleImage;
@dynamic backgroundImage;
@dynamic gameIdsArray, gameIdsArray_Count;
@dynamic normalizedLogin;
@dynamic hasBiography, biography;
@dynamic isSysop;
@dynamic channelMembershipsArray, channelMembershipsArray_Count;
@dynamic relationsArray, relationsArray_Count;
@dynamic createdAt;
@dynamic updatedAt;
@dynamic ephemeral;
@dynamic facebookId;
@dynamic avatarImageIsAutogenerated;
@dynamic nameIsAutogenerated;
@dynamic googleId;
@dynamic hasSetPassword;
@dynamic hasMobileClient;

typedef struct User__storage_ {
  uint32_t _has_storage_[2];
  User_UserStatus status;
  NSString *id_p;
  NSString *login;
  NSData *password;
  NSString *email;
  NSString *displayName;
  NSString *avatarImage;
  NSMutableArray *channelIdsArray;
  NSMutableArray *channelsArray;
  NSString *titleImage;
  NSString *backgroundImage;
  NSMutableArray *gameIdsArray;
  NSString *normalizedLogin;
  UserBiography *biography;
  NSMutableArray *channelMembershipsArray;
  NSMutableArray *relationsArray;
  NSString *facebookId;
  NSString *googleId;
  int64_t createdAt;
  int64_t updatedAt;
} User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(User__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "login",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Login,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(User__storage_, login),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Password,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(User__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(User__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_DisplayName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(User__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_AvatarImage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(User__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_ChannelIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, channelIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = User_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emailConfirmed",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_EmailConfirmed,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = User_UserStatus_EnumDescriptor,
        .number = User_FieldNumber_Status,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(User__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "termsOfService",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_TermsOfService,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "newsletter",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Newsletter,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_TitleImage,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(User__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_BackgroundImage,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(User__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_GameIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, gameIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "normalizedLogin",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_NormalizedLogin,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(User__storage_, normalizedLogin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "biography",
        .dataTypeSpecific.className = GPBStringifySymbol(UserBiography),
        .number = User_FieldNumber_Biography,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(User__storage_, biography),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isSysop",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_IsSysop,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "channelMembershipsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelMembership),
        .number = User_FieldNumber_ChannelMembershipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, channelMembershipsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "relationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ProprietaryUserGroupRecord),
        .number = User_FieldNumber_RelationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(User__storage_, relationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_CreatedAt,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(User__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_UpdatedAt,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(User__storage_, updatedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ephemeral",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Ephemeral,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "facebookId",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_FacebookId,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(User__storage_, facebookId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarImageIsAutogenerated",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_AvatarImageIsAutogenerated,
        .hasIndex = 24,
        .offset = 25,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "nameIsAutogenerated",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_NameIsAutogenerated,
        .hasIndex = 26,
        .offset = 27,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "googleId",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_GoogleId,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(User__storage_, googleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasSetPassword",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_HasSetPassword,
        .hasIndex = 29,
        .offset = 30,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hasMobileClient",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_HasMobileClient,
        .hasIndex = 31,
        .offset = 32,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[User class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(User__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\023\000channelMemberships\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t User_Status_RawValue(User *message) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetUser_Status_RawValue(User *message, int32_t value) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum User_UserStatus

GPBEnumDescriptor *User_UserStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Offline\000Online\000Away\000Busy\000";
    static const int32_t values[] = {
        User_UserStatus_Unknown,
        User_UserStatus_Offline,
        User_UserStatus_Online,
        User_UserStatus_Away,
        User_UserStatus_Busy,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(User_UserStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:User_UserStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL User_UserStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case User_UserStatus_Unknown:
    case User_UserStatus_Offline:
    case User_UserStatus_Online:
    case User_UserStatus_Away:
    case User_UserStatus_Busy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserProfile

@implementation UserProfile

@dynamic id_p;
@dynamic displayName;
@dynamic avatarImage;
@dynamic titleImage;
@dynamic backgroundImage;
@dynamic hasBiography, biography;
@dynamic gamesArray, gamesArray_Count;
@dynamic badgesArray, badgesArray_Count;
@dynamic groupsArray, groupsArray_Count;
@dynamic accountsArray, accountsArray_Count;
@dynamic hubsArray, hubsArray_Count;

typedef struct UserProfile__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *displayName;
  NSString *avatarImage;
  NSString *titleImage;
  NSString *backgroundImage;
  UserBiography *biography;
  NSMutableArray *gamesArray;
  NSMutableArray *badgesArray;
  NSMutableArray *groupsArray;
  NSMutableArray *accountsArray;
  NSMutableArray *hubsArray;
} UserProfile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserProfile_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserProfile__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = UserProfile_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserProfile__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = UserProfile_FieldNumber_AvatarImage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserProfile__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = UserProfile_FieldNumber_TitleImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserProfile__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = UserProfile_FieldNumber_BackgroundImage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserProfile__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "biography",
        .dataTypeSpecific.className = GPBStringifySymbol(UserBiography),
        .number = UserProfile_FieldNumber_Biography,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserProfile__storage_, biography),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserGame),
        .number = UserProfile_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserProfile__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "badgesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserBadge),
        .number = UserProfile_FieldNumber_BadgesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserProfile__storage_, badgesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMembership),
        .number = UserProfile_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserProfile__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserAccount),
        .number = UserProfile_FieldNumber_AccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserProfile__storage_, accountsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hubsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Hub),
        .number = UserProfile_FieldNumber_HubsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserProfile__storage_, hubsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserProfile class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserProfile__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserBiography

@implementation UserBiography

@dynamic introduction;
@dynamic languages;

typedef struct UserBiography__storage_ {
  uint32_t _has_storage_[1];
  NSString *introduction;
  NSString *languages;
} UserBiography__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "introduction",
        .dataTypeSpecific.className = NULL,
        .number = UserBiography_FieldNumber_Introduction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserBiography__storage_, introduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "languages",
        .dataTypeSpecific.className = NULL,
        .number = UserBiography_FieldNumber_Languages,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserBiography__storage_, languages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserBiography class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserBiography__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserAccount

@implementation UserAccount

@dynamic id_p;
@dynamic accountId;
@dynamic name;
@dynamic type;

typedef struct UserAccount__storage_ {
  uint32_t _has_storage_[1];
  UserAccount_AccountType type;
  NSString *id_p;
  NSString *accountId;
  NSString *name;
} UserAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserAccount_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserAccount__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = UserAccount_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserAccount__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = UserAccount_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserAccount__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = UserAccount_AccountType_EnumDescriptor,
        .number = UserAccount_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserAccount__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAccount class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserAccount__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserAccount_Type_RawValue(UserAccount *message) {
  GPBDescriptor *descriptor = [UserAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserAccount_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserAccount_Type_RawValue(UserAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [UserAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserAccount_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserAccount_AccountType

GPBEnumDescriptor *UserAccount_AccountType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Steam\000Psn\000Xbox\000Uplay\000BattleNet\000O"
        "rigin\000PvpNet\000Facebook\000PlayerMe\000Teamspeak"
        "\000Twitch\000Twitter\000Weblink\000Youtube\000";
    static const int32_t values[] = {
        UserAccount_AccountType_Unknown,
        UserAccount_AccountType_Steam,
        UserAccount_AccountType_Psn,
        UserAccount_AccountType_Xbox,
        UserAccount_AccountType_Uplay,
        UserAccount_AccountType_BattleNet,
        UserAccount_AccountType_Origin,
        UserAccount_AccountType_PvpNet,
        UserAccount_AccountType_Facebook,
        UserAccount_AccountType_PlayerMe,
        UserAccount_AccountType_Teamspeak,
        UserAccount_AccountType_Twitch,
        UserAccount_AccountType_Twitter,
        UserAccount_AccountType_Weblink,
        UserAccount_AccountType_Youtube,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserAccount_AccountType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserAccount_AccountType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserAccount_AccountType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserAccount_AccountType_Unknown:
    case UserAccount_AccountType_Steam:
    case UserAccount_AccountType_Psn:
    case UserAccount_AccountType_Xbox:
    case UserAccount_AccountType_Uplay:
    case UserAccount_AccountType_BattleNet:
    case UserAccount_AccountType_Origin:
    case UserAccount_AccountType_PvpNet:
    case UserAccount_AccountType_Facebook:
    case UserAccount_AccountType_PlayerMe:
    case UserAccount_AccountType_Teamspeak:
    case UserAccount_AccountType_Twitch:
    case UserAccount_AccountType_Twitter:
    case UserAccount_AccountType_Weblink:
    case UserAccount_AccountType_Youtube:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserGame

@implementation UserGame

@dynamic id_p;
@dynamic rank;
@dynamic hasGame, game;

typedef struct UserGame__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *rank;
  Game *game;
} UserGame__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserGame_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGame__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rank",
        .dataTypeSpecific.className = NULL,
        .number = UserGame_FieldNumber_Rank,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserGame__storage_, rank),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = UserGame_FieldNumber_Game,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserGame__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGame class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGame__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserAgent

@implementation UserAgent

@dynamic id_p;
@dynamic userId;
@dynamic name;
@dynamic type;
@dynamic lastToken;
@dynamic lastLogin;
@dynamic lastIp;
@dynamic hasUser, user;

typedef struct UserAgent__storage_ {
  uint32_t _has_storage_[1];
  UserAgent_UserAgentType type;
  NSString *id_p;
  NSString *userId;
  NSString *name;
  NSString *lastToken;
  NSString *lastLogin;
  NSString *lastIp;
  User *user;
} UserAgent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserAgent__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserAgent__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserAgent__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = UserAgent_UserAgentType_EnumDescriptor,
        .number = UserAgent_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserAgent__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lastToken",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_LastToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserAgent__storage_, lastToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastLogin",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_LastLogin,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserAgent__storage_, lastLogin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastIp",
        .dataTypeSpecific.className = NULL,
        .number = UserAgent_FieldNumber_LastIp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserAgent__storage_, lastIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = UserAgent_FieldNumber_User,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserAgent__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAgent class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserAgent__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserAgent_Type_RawValue(UserAgent *message) {
  GPBDescriptor *descriptor = [UserAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserAgent_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserAgent_Type_RawValue(UserAgent *message, int32_t value) {
  GPBDescriptor *descriptor = [UserAgent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserAgent_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum UserAgent_UserAgentType

GPBEnumDescriptor *UserAgent_UserAgentType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Web\000Android\000Ios\000WebEmbedded\000Bot\000"
        "LoadTest\000ManagementConsole\000";
    static const int32_t values[] = {
        UserAgent_UserAgentType_Unknown,
        UserAgent_UserAgentType_Web,
        UserAgent_UserAgentType_Android,
        UserAgent_UserAgentType_Ios,
        UserAgent_UserAgentType_WebEmbedded,
        UserAgent_UserAgentType_Bot,
        UserAgent_UserAgentType_LoadTest,
        UserAgent_UserAgentType_ManagementConsole,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserAgent_UserAgentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserAgent_UserAgentType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserAgent_UserAgentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserAgent_UserAgentType_Unknown:
    case UserAgent_UserAgentType_Web:
    case UserAgent_UserAgentType_Android:
    case UserAgent_UserAgentType_Ios:
    case UserAgent_UserAgentType_WebEmbedded:
    case UserAgent_UserAgentType_Bot:
    case UserAgent_UserAgentType_LoadTest:
    case UserAgent_UserAgentType_ManagementConsole:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserAgentConnection

@implementation UserAgentConnection

@dynamic id_p;
@dynamic agentId;
@dynamic timestamp;

typedef struct UserAgentConnection__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *agentId;
  NSString *timestamp;
} UserAgentConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserAgentConnection_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserAgentConnection__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agentId",
        .dataTypeSpecific.className = NULL,
        .number = UserAgentConnection_FieldNumber_AgentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserAgentConnection__storage_, agentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = UserAgentConnection_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserAgentConnection__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAgentConnection class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserAgentConnection__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelUser

@implementation ChannelUser

@dynamic hasUser, user;
@dynamic typeV1;
@dynamic type;
@dynamic voiceStatus;

typedef struct ChannelUser__storage_ {
  uint32_t _has_storage_[1];
  ChannelUser_ChannelUserType typeV1;
  ChannelMembershipRecord_MembershipType type;
  ChannelMembershipRecord_VoiceStatus voiceStatus;
  ChatUser *user;
} ChannelUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = ChannelUser_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelUser__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "typeV1",
        .dataTypeSpecific.enumDescFunc = ChannelUser_ChannelUserType_EnumDescriptor,
        .number = ChannelUser_FieldNumber_TypeV1,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelUser__storage_, typeV1),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = ChannelUser_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelUser__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "voiceStatus",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_VoiceStatus_EnumDescriptor,
        .number = ChannelUser_FieldNumber_VoiceStatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelUser__storage_, voiceStatus),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelUser class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelUser__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChannelUser_TypeV1_RawValue(ChannelUser *message) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_TypeV1];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelUser_TypeV1_RawValue(ChannelUser *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_TypeV1];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ChannelUser_Type_RawValue(ChannelUser *message) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelUser_Type_RawValue(ChannelUser *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ChannelUser_VoiceStatus_RawValue(ChannelUser *message) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_VoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelUser_VoiceStatus_RawValue(ChannelUser *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelUser_FieldNumber_VoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChannelUser_ChannelUserType

GPBEnumDescriptor *ChannelUser_ChannelUserType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Owner\000Member\000Chatter\000";
    static const int32_t values[] = {
        ChannelUser_ChannelUserType_Unknown,
        ChannelUser_ChannelUserType_Owner,
        ChannelUser_ChannelUserType_Member,
        ChannelUser_ChannelUserType_Chatter,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelUser_ChannelUserType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelUser_ChannelUserType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelUser_ChannelUserType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelUser_ChannelUserType_Unknown:
    case ChannelUser_ChannelUserType_Owner:
    case ChannelUser_ChannelUserType_Member:
    case ChannelUser_ChannelUserType_Chatter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChatUser

@implementation ChatUser

@dynamic id_p;
@dynamic displayName;
@dynamic avatarImage;
@dynamic isModerator;
@dynamic status;
@dynamic titleImage;
@dynamic backgroundImage;
@dynamic ephemeral;

typedef struct ChatUser__storage_ {
  uint32_t _has_storage_[1];
  User_UserStatus status;
  NSString *id_p;
  NSString *displayName;
  NSString *avatarImage;
  NSString *titleImage;
  NSString *backgroundImage;
} ChatUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatUser__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatUser__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarImage",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_AvatarImage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatUser__storage_, avatarImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isModerator",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_IsModerator,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = User_UserStatus_EnumDescriptor,
        .number = ChatUser_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatUser__storage_, status),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_TitleImage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatUser__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_BackgroundImage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChatUser__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ephemeral",
        .dataTypeSpecific.className = NULL,
        .number = ChatUser_FieldNumber_Ephemeral,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatUser class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatUser__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatUser_Status_RawValue(ChatUser *message) {
  GPBDescriptor *descriptor = [ChatUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatUser_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetChatUser_Status_RawValue(ChatUser *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatUser_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ChatUserInfo

@implementation ChatUserInfo

@dynamic hasUser, user;
@dynamic friendsArray, friendsArray_Count;
@dynamic groupMembershipsArray, groupMembershipsArray_Count;
@dynamic gamesArray, gamesArray_Count;

typedef struct ChatUserInfo__storage_ {
  uint32_t _has_storage_[1];
  ChatUser *user;
  NSMutableArray *friendsArray;
  NSMutableArray *groupMembershipsArray;
  NSMutableArray *gamesArray;
} ChatUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = ChatUserInfo_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatUserInfo__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "friendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = ChatUserInfo_FieldNumber_FriendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatUserInfo__storage_, friendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupMembershipsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMembership),
        .number = ChatUserInfo_FieldNumber_GroupMembershipsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatUserInfo__storage_, groupMembershipsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = ChatUserInfo_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatUserInfo__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatUserInfo class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatUserInfo__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProprietaryUserGroupRecord

@implementation ProprietaryUserGroupRecord

@dynamic id_p;
@dynamic userId;
@dynamic type;

typedef struct ProprietaryUserGroupRecord__storage_ {
  uint32_t _has_storage_[1];
  ProprietaryUserGroupRecord_Type type;
  NSString *id_p;
  NSString *userId;
} ProprietaryUserGroupRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ProprietaryUserGroupRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProprietaryUserGroupRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ProprietaryUserGroupRecord_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProprietaryUserGroupRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ProprietaryUserGroupRecord_Type_EnumDescriptor,
        .number = ProprietaryUserGroupRecord_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProprietaryUserGroupRecord__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProprietaryUserGroupRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProprietaryUserGroupRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ProprietaryUserGroupRecord_Type_RawValue(ProprietaryUserGroupRecord *message) {
  GPBDescriptor *descriptor = [ProprietaryUserGroupRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProprietaryUserGroupRecord_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetProprietaryUserGroupRecord_Type_RawValue(ProprietaryUserGroupRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [ProprietaryUserGroupRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ProprietaryUserGroupRecord_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ProprietaryUserGroupRecord_Type

GPBEnumDescriptor *ProprietaryUserGroupRecord_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000None\000EslAdmins\000EslVideo\000";
    static const int32_t values[] = {
        ProprietaryUserGroupRecord_Type_Unknown,
        ProprietaryUserGroupRecord_Type_None,
        ProprietaryUserGroupRecord_Type_EslAdmins,
        ProprietaryUserGroupRecord_Type_EslVideo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ProprietaryUserGroupRecord_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ProprietaryUserGroupRecord_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ProprietaryUserGroupRecord_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ProprietaryUserGroupRecord_Type_Unknown:
    case ProprietaryUserGroupRecord_Type_None:
    case ProprietaryUserGroupRecord_Type_EslAdmins:
    case ProprietaryUserGroupRecord_Type_EslVideo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserExternalIDRecord

@implementation UserExternalIDRecord

@dynamic id_p;
@dynamic createdAt;
@dynamic updatedAt;
@dynamic userId;
@dynamic groupId;
@dynamic externalId;

typedef struct UserExternalIDRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *userId;
  NSString *groupId;
  NSString *externalId;
  int64_t createdAt;
  int64_t updatedAt;
} UserExternalIDRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_CreatedAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_UpdatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, updatedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_GroupId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "externalId",
        .dataTypeSpecific.className = NULL,
        .number = UserExternalIDRecord_FieldNumber_ExternalId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserExternalIDRecord__storage_, externalId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserExternalIDRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserExternalIDRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendRequest

@implementation FriendRequest

@dynamic hasUser, user;
@dynamic message;

typedef struct FriendRequest__storage_ {
  uint32_t _has_storage_[1];
  ChatUser *user;
  NSString *message;
} FriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = FriendRequest_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendRequest__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = FriendRequest_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendRequest class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendRequest__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Channel

@implementation Channel

@dynamic id_p;
@dynamic title;
@dynamic type;
@dynamic directUserIdsArray, directUserIdsArray_Count;
@dynamic directUsersArray, directUsersArray_Count;
@dynamic groupId;
@dynamic bansArray, bansArray_Count;
@dynamic gameId;
@dynamic hasGame, game;
@dynamic tagsArray, tagsArray_Count;
@dynamic tagList;
@dynamic topic;
@dynamic hubId;
@dynamic hasHub, hub;

typedef struct Channel__storage_ {
  uint32_t _has_storage_[1];
  Channel_ChannelType type;
  NSString *id_p;
  NSString *title;
  NSMutableArray *directUserIdsArray;
  NSMutableArray *directUsersArray;
  NSString *groupId;
  NSMutableArray *bansArray;
  NSString *gameId;
  Game *game;
  NSMutableArray *tagsArray;
  NSString *tagList;
  NSString *topic;
  NSString *hubId;
  Hub *hub;
} Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Channel__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Channel__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Channel_ChannelType_EnumDescriptor,
        .number = Channel_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Channel__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "directUserIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_DirectUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Channel__storage_, directUserIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "directUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = Channel_FieldNumber_DirectUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Channel__storage_, directUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_GroupId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Channel__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bansArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelBan),
        .number = Channel_FieldNumber_BansArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Channel__storage_, bansArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_GameId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Channel__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = Channel_FieldNumber_Game,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Channel__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Channel__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagList",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_TagList,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Channel__storage_, tagList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "topic",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_Topic,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Channel__storage_, topic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hubId",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_HubId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Channel__storage_, hubId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hub",
        .dataTypeSpecific.className = GPBStringifySymbol(Hub),
        .number = Channel_FieldNumber_Hub,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Channel__storage_, hub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Channel class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Channel__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Channel_Type_RawValue(Channel *message) {
  GPBDescriptor *descriptor = [Channel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Channel_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannel_Type_RawValue(Channel *message, int32_t value) {
  GPBDescriptor *descriptor = [Channel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Channel_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Channel_ChannelType

GPBEnumDescriptor *Channel_ChannelType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Private\000Public\000Direct\000Game\000Hub\000";
    static const int32_t values[] = {
        Channel_ChannelType_Unknown,
        Channel_ChannelType_Private,
        Channel_ChannelType_Public,
        Channel_ChannelType_Direct,
        Channel_ChannelType_Game,
        Channel_ChannelType_Hub,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Channel_ChannelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Channel_ChannelType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Channel_ChannelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Channel_ChannelType_Unknown:
    case Channel_ChannelType_Private:
    case Channel_ChannelType_Public:
    case Channel_ChannelType_Direct:
    case Channel_ChannelType_Game:
    case Channel_ChannelType_Hub:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChannelBan

@implementation ChannelBan

@dynamic userId;
@dynamic expiry;

typedef struct ChannelBan__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  int64_t expiry;
} ChannelBan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBan_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelBan__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiry",
        .dataTypeSpecific.className = NULL,
        .number = ChannelBan_FieldNumber_Expiry,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelBan__storage_, expiry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelBan class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelBan__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelMembership

@implementation ChannelMembership

@dynamic channelId;
@dynamic userId;
@dynamic type;
@dynamic hasChannel, channel;
@dynamic hasPermissions, permissions;
@dynamic voiceStatus;

typedef struct ChannelMembership__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_MembershipType type;
  ChannelMembershipRecord_VoiceStatus voiceStatus;
  NSString *channelId;
  NSString *userId;
  Channel *channel;
  ChannelPermissions *permissions;
} ChannelMembership__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelMembership_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelMembership_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = ChannelMembership_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ChannelMembership_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPermissions),
        .number = ChannelMembership_FieldNumber_Permissions,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, permissions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceStatus",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_VoiceStatus_EnumDescriptor,
        .number = ChannelMembership_FieldNumber_VoiceStatus,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelMembership__storage_, voiceStatus),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelMembership class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelMembership__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChannelMembership_Type_RawValue(ChannelMembership *message) {
  GPBDescriptor *descriptor = [ChannelMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembership_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelMembership_Type_RawValue(ChannelMembership *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembership_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ChannelMembership_VoiceStatus_RawValue(ChannelMembership *message) {
  GPBDescriptor *descriptor = [ChannelMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembership_FieldNumber_VoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelMembership_VoiceStatus_RawValue(ChannelMembership *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembership_FieldNumber_VoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ChannelMembershipRecord

@implementation ChannelMembershipRecord

@dynamic id_p;
@dynamic channelId;
@dynamic userId;
@dynamic type;
@dynamic hasChannel, channel;
@dynamic hasUser, user;
@dynamic hasPermissions, permissions;
@dynamic voiceStatus;

typedef struct ChannelMembershipRecord__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_MembershipType type;
  ChannelMembershipRecord_VoiceStatus voiceStatus;
  NSString *id_p;
  NSString *channelId;
  NSString *userId;
  Channel *channel;
  User *user;
  ChannelPermissions *permissions;
} ChannelMembershipRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ChannelMembershipRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelMembershipRecord_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, channelId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelMembershipRecord_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = ChannelMembershipRecord_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = ChannelMembershipRecord_FieldNumber_Channel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = ChannelMembershipRecord_FieldNumber_User,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelPermissions),
        .number = ChannelMembershipRecord_FieldNumber_Permissions,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, permissions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voiceStatus",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_VoiceStatus_EnumDescriptor,
        .number = ChannelMembershipRecord_FieldNumber_VoiceStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChannelMembershipRecord__storage_, voiceStatus),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelMembershipRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelMembershipRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChannelMembershipRecord_Type_RawValue(ChannelMembershipRecord *message) {
  GPBDescriptor *descriptor = [ChannelMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembershipRecord_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelMembershipRecord_Type_RawValue(ChannelMembershipRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembershipRecord_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ChannelMembershipRecord_VoiceStatus_RawValue(ChannelMembershipRecord *message) {
  GPBDescriptor *descriptor = [ChannelMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembershipRecord_FieldNumber_VoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetChannelMembershipRecord_VoiceStatus_RawValue(ChannelMembershipRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [ChannelMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChannelMembershipRecord_FieldNumber_VoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ChannelMembershipRecord_MembershipType

GPBEnumDescriptor *ChannelMembershipRecord_MembershipType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000None\000Subscriber\000Moderator\000Modera"
        "torGroup\000Owner\000";
    static const int32_t values[] = {
        ChannelMembershipRecord_MembershipType_Unknown,
        ChannelMembershipRecord_MembershipType_None,
        ChannelMembershipRecord_MembershipType_Subscriber,
        ChannelMembershipRecord_MembershipType_Moderator,
        ChannelMembershipRecord_MembershipType_ModeratorGroup,
        ChannelMembershipRecord_MembershipType_Owner,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelMembershipRecord_MembershipType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelMembershipRecord_MembershipType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelMembershipRecord_MembershipType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelMembershipRecord_MembershipType_Unknown:
    case ChannelMembershipRecord_MembershipType_None:
    case ChannelMembershipRecord_MembershipType_Subscriber:
    case ChannelMembershipRecord_MembershipType_Moderator:
    case ChannelMembershipRecord_MembershipType_ModeratorGroup:
    case ChannelMembershipRecord_MembershipType_Owner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChannelMembershipRecord_VoiceStatus

GPBEnumDescriptor *ChannelMembershipRecord_VoiceStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "VsUnknown\000VsOffline\000VsOnlineMuted\000VsOnli"
        "ne\000";
    static const int32_t values[] = {
        ChannelMembershipRecord_VoiceStatus_VsUnknown,
        ChannelMembershipRecord_VoiceStatus_VsOffline,
        ChannelMembershipRecord_VoiceStatus_VsOnlineMuted,
        ChannelMembershipRecord_VoiceStatus_VsOnline,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelMembershipRecord_VoiceStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelMembershipRecord_VoiceStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelMembershipRecord_VoiceStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelMembershipRecord_VoiceStatus_VsUnknown:
    case ChannelMembershipRecord_VoiceStatus_VsOffline:
    case ChannelMembershipRecord_VoiceStatus_VsOnlineMuted:
    case ChannelMembershipRecord_VoiceStatus_VsOnline:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChannelPermissions

@implementation ChannelPermissions

@dynamic kickBanUser;
@dynamic inviteUser;
@dynamic setChannelRole;
@dynamic editStickyMessage;
@dynamic deleteMessage;
@dynamic editChannel;
@dynamic deleteChannel;

typedef struct ChannelPermissions__storage_ {
  uint32_t _has_storage_[1];
} ChannelPermissions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kickBanUser",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_KickBanUser,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inviteUser",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_InviteUser,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "setChannelRole",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_SetChannelRole,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "editStickyMessage",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_EditStickyMessage,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deleteMessage",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_DeleteMessage,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "editChannel",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_EditChannel,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deleteChannel",
        .dataTypeSpecific.className = NULL,
        .number = ChannelPermissions_FieldNumber_DeleteChannel,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelPermissions class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelPermissions__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Group

@implementation Group

@dynamic id_p;
@dynamic owner;
@dynamic name;
@dynamic description_p;
@dynamic titleImage;
@dynamic backgroundImage;
@dynamic channelsArray, channelsArray_Count;
@dynamic membersArray, membersArray_Count;
@dynamic memberCount;
@dynamic subscriberCount;

typedef struct Group__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberCount;
  int32_t subscriberCount;
  NSString *id_p;
  NSString *owner;
  NSString *name;
  NSString *description_p;
  NSString *titleImage;
  NSString *backgroundImage;
  NSMutableArray *channelsArray;
  NSMutableArray *membersArray;
} Group__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Group__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Owner,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Group__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Group__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Group__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_TitleImage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Group__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImage",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_BackgroundImage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Group__storage_, backgroundImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = Group_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Group__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = Group_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Group__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_MemberCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Group__storage_, memberCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subscriberCount",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_SubscriberCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Group__storage_, subscriberCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Group class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Group__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPermissions

@implementation GroupPermissions

@dynamic editGroup;
@dynamic createChannel;
@dynamic joinPublicChannel;
@dynamic joinPrivateChannel;
@dynamic inviteUser;
@dynamic setUserMembershipType;

typedef struct GroupPermissions__storage_ {
  uint32_t _has_storage_[1];
} GroupPermissions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "editGroup",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_EditGroup,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "createChannel",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_CreateChannel,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinPublicChannel",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_JoinPublicChannel,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joinPrivateChannel",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_JoinPrivateChannel,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inviteUser",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_InviteUser,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "setUserMembershipType",
        .dataTypeSpecific.className = NULL,
        .number = GroupPermissions_FieldNumber_SetUserMembershipType,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPermissions class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPermissions__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMembership

@implementation GroupMembership

@dynamic hasGroup, group;
@dynamic typeV1;
@dynamic groupId;
@dynamic userId;
@dynamic type;
@dynamic hasPermissions, permissions;

typedef struct GroupMembership__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipTypeV1 typeV1;
  GroupMembershipRecord_MembershipType type;
  Group *group;
  NSString *groupId;
  NSString *userId;
  GroupPermissions *permissions;
} GroupMembership__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupMembership_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "typeV1",
        .dataTypeSpecific.enumDescFunc = GroupMembershipTypeV1_EnumDescriptor,
        .number = GroupMembership_FieldNumber_TypeV1,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, typeV1),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembership_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembership_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = GroupMembership_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupPermissions),
        .number = GroupMembership_FieldNumber_Permissions,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMembership__storage_, permissions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMembership class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembership__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupMembership_TypeV1_RawValue(GroupMembership *message) {
  GPBDescriptor *descriptor = [GroupMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembership_FieldNumber_TypeV1];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupMembership_TypeV1_RawValue(GroupMembership *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembership_FieldNumber_TypeV1];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GroupMembership_Type_RawValue(GroupMembership *message) {
  GPBDescriptor *descriptor = [GroupMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembership_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupMembership_Type_RawValue(GroupMembership *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembership_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GroupMembershipRecord

@implementation GroupMembershipRecord

@dynamic id_p;
@dynamic groupId;
@dynamic userId;
@dynamic type;
@dynamic hasGroup, group;
@dynamic hasUser, user;
@dynamic hasPermissions, permissions;
@dynamic createdAt;
@dynamic updatedAt;

typedef struct GroupMembershipRecord__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipRecord_MembershipType type;
  NSString *id_p;
  NSString *groupId;
  NSString *userId;
  Group *group;
  User *user;
  GroupPermissions *permissions;
  int64_t createdAt;
  int64_t updatedAt;
} GroupMembershipRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembershipRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembershipRecord_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembershipRecord_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = GroupMembershipRecord_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupMembershipRecord_FieldNumber_Group,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = GroupMembershipRecord_FieldNumber_User,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissions",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupPermissions),
        .number = GroupMembershipRecord_FieldNumber_Permissions,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, permissions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembershipRecord_FieldNumber_CreatedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.className = NULL,
        .number = GroupMembershipRecord_FieldNumber_UpdatedAt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GroupMembershipRecord__storage_, updatedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMembershipRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembershipRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupMembershipRecord_Type_RawValue(GroupMembershipRecord *message) {
  GPBDescriptor *descriptor = [GroupMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembershipRecord_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupMembershipRecord_Type_RawValue(GroupMembershipRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupMembershipRecord_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GroupMembershipRecord_MembershipType

GPBEnumDescriptor *GroupMembershipRecord_MembershipType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000None\000Guest\000Member\000Moderator\000Owne"
        "r\000";
    static const int32_t values[] = {
        GroupMembershipRecord_MembershipType_Unknown,
        GroupMembershipRecord_MembershipType_None,
        GroupMembershipRecord_MembershipType_Guest,
        GroupMembershipRecord_MembershipType_Member,
        GroupMembershipRecord_MembershipType_Moderator,
        GroupMembershipRecord_MembershipType_Owner,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GroupMembershipRecord_MembershipType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GroupMembershipRecord_MembershipType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GroupMembershipRecord_MembershipType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GroupMembershipRecord_MembershipType_Unknown:
    case GroupMembershipRecord_MembershipType_None:
    case GroupMembershipRecord_MembershipType_Guest:
    case GroupMembershipRecord_MembershipType_Member:
    case GroupMembershipRecord_MembershipType_Moderator:
    case GroupMembershipRecord_MembershipType_Owner:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GroupMember

@implementation GroupMember

@dynamic id_p;
@dynamic userId;
@dynamic groupId;

typedef struct GroupMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *userId;
  NSString *groupId;
} GroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMember__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMember__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMember__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMember class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMember__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInvitation

@implementation GroupInvitation

@dynamic id_p;
@dynamic groupId;
@dynamic code;
@dynamic inviterId;

typedef struct GroupInvitation__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *groupId;
  NSString *code;
  NSString *inviterId;
} GroupInvitation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvitation_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInvitation__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvitation_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInvitation__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvitation_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInvitation__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviterId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvitation_FieldNumber_InviterId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInvitation__storage_, inviterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInvitation class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInvitation__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PotentialGroupMember

@implementation PotentialGroupMember

@dynamic identifierOneOfCase;
@dynamic userId;
@dynamic emailAddress;

typedef struct PotentialGroupMember__storage_ {
  uint32_t _has_storage_[2];
  OptionalString *userId;
  OptionalString *emailAddress;
} PotentialGroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = PotentialGroupMember_FieldNumber_UserId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PotentialGroupMember__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = PotentialGroupMember_FieldNumber_EmailAddress,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(PotentialGroupMember__storage_, emailAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PotentialGroupMember class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PotentialGroupMember__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "identifier",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void PotentialGroupMember_ClearIdentifierOneOfCase(PotentialGroupMember *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GroupInvite

@implementation GroupInvite

@dynamic id_p;
@dynamic createdAt;
@dynamic updatedAt;
@dynamic groupId;
@dynamic inviterId;
@dynamic userId;
@dynamic email;
@dynamic code;
@dynamic type;

typedef struct GroupInvite__storage_ {
  uint32_t _has_storage_[1];
  GroupMembershipRecord_MembershipType type;
  NSString *id_p;
  NSString *groupId;
  NSString *inviterId;
  NSString *userId;
  NSString *email;
  NSString *code;
  int64_t createdAt;
  int64_t updatedAt;
} GroupInvite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_CreatedAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_UpdatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, updatedAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_GroupId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviterId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_InviterId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, inviterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_UserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Email,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, email),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Code,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GroupMembershipRecord_MembershipType_EnumDescriptor,
        .number = GroupInvite_FieldNumber_Type,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInvite class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInvite__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GroupInvite_Type_RawValue(GroupInvite *message) {
  GPBDescriptor *descriptor = [GroupInvite descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupInvite_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGroupInvite_Type_RawValue(GroupInvite *message, int32_t value) {
  GPBDescriptor *descriptor = [GroupInvite descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GroupInvite_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Game

@implementation Game

@dynamic id_p;
@dynamic name;
@dynamic titleImage;
@dynamic backgroundImagesArray, backgroundImagesArray_Count;
@dynamic readOnly;
@dynamic shortName;

typedef struct Game__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  NSString *titleImage;
  NSMutableArray *backgroundImagesArray;
  NSString *shortName;
} Game__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Game__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Game__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_TitleImage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Game__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImagesArray",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_BackgroundImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Game__storage_, backgroundImagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readOnly",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_ReadOnly,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shortName",
        .dataTypeSpecific.className = NULL,
        .number = Game_FieldNumber_ShortName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Game__storage_, shortName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Game class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Game__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameMembership

@implementation GameMembership

@dynamic gameId;
@dynamic userId;
@dynamic type;
@dynamic hasGame, game;

typedef struct GameMembership__storage_ {
  uint32_t _has_storage_[1];
  GameMembershipRecord_MembershipType type;
  NSString *gameId;
  NSString *userId;
  Game *game;
} GameMembership__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = GameMembership_FieldNumber_GameId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameMembership__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GameMembership_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameMembership__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GameMembershipRecord_MembershipType_EnumDescriptor,
        .number = GameMembership_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameMembership__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameMembership_FieldNumber_Game,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GameMembership__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameMembership class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameMembership__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GameMembership_Type_RawValue(GameMembership *message) {
  GPBDescriptor *descriptor = [GameMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GameMembership_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGameMembership_Type_RawValue(GameMembership *message, int32_t value) {
  GPBDescriptor *descriptor = [GameMembership descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GameMembership_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GameMembershipRecord

@implementation GameMembershipRecord

@dynamic id_p;
@dynamic gameId;
@dynamic userId;
@dynamic type;
@dynamic hasGame, game;
@dynamic hasUser, user;

typedef struct GameMembershipRecord__storage_ {
  uint32_t _has_storage_[1];
  GameMembershipRecord_MembershipType type;
  NSString *id_p;
  NSString *gameId;
  NSString *userId;
  Game *game;
  User *user;
} GameMembershipRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GameMembershipRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gameId",
        .dataTypeSpecific.className = NULL,
        .number = GameMembershipRecord_FieldNumber_GameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, gameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GameMembershipRecord_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GameMembershipRecord_MembershipType_EnumDescriptor,
        .number = GameMembershipRecord_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameMembershipRecord_FieldNumber_Game,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = GameMembershipRecord_FieldNumber_User,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GameMembershipRecord__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameMembershipRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameMembershipRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GameMembershipRecord_Type_RawValue(GameMembershipRecord *message) {
  GPBDescriptor *descriptor = [GameMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GameMembershipRecord_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGameMembershipRecord_Type_RawValue(GameMembershipRecord *message, int32_t value) {
  GPBDescriptor *descriptor = [GameMembershipRecord descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GameMembershipRecord_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GameMembershipRecord_MembershipType

GPBEnumDescriptor *GameMembershipRecord_MembershipType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000None\000Member\000";
    static const int32_t values[] = {
        GameMembershipRecord_MembershipType_Unknown,
        GameMembershipRecord_MembershipType_None,
        GameMembershipRecord_MembershipType_Member,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GameMembershipRecord_MembershipType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GameMembershipRecord_MembershipType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GameMembershipRecord_MembershipType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GameMembershipRecord_MembershipType_Unknown:
    case GameMembershipRecord_MembershipType_None:
    case GameMembershipRecord_MembershipType_Member:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GameEditEntry

@implementation GameEditEntry

@dynamic gameOneOfCase;
@dynamic existingGameId;
@dynamic newGame;
@dynamic editedGame;

typedef struct GameEditEntry__storage_ {
  uint32_t _has_storage_[2];
  OptionalString *existingGameId;
  Game *newGame;
  Game *editedGame;
} GameEditEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "existingGameId",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = GameEditEntry_FieldNumber_ExistingGameId,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GameEditEntry__storage_, existingGameId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newGame",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameEditEntry_FieldNumber_NewGame,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GameEditEntry__storage_, newGame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "editedGame",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameEditEntry_FieldNumber_EditedGame,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GameEditEntry__storage_, editedGame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameEditEntry class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameEditEntry__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "game",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GameEditEntry_ClearGameOneOfCase(GameEditEntry *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - OptionalGames

@implementation OptionalGames

@dynamic gamesArray, gamesArray_Count;

typedef struct OptionalGames__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *gamesArray;
} OptionalGames__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GameEditEntry),
        .number = OptionalGames_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OptionalGames__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OptionalGames class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OptionalGames__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameRecord

@implementation GameRecord

@dynamic id_p;
@dynamic userId;
@dynamic name;
@dynamic titleImage;
@dynamic backgroundImagesArray, backgroundImagesArray_Count;
@dynamic shortName;

typedef struct GameRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *userId;
  NSString *name;
  NSString *titleImage;
  NSMutableArray *backgroundImagesArray;
  NSString *shortName;
} GameRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameRecord__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameRecord__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameRecord__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleImage",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_TitleImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GameRecord__storage_, titleImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backgroundImagesArray",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_BackgroundImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GameRecord__storage_, backgroundImagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shortName",
        .dataTypeSpecific.className = NULL,
        .number = GameRecord_FieldNumber_ShortName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GameRecord__storage_, shortName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameRecord class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameRecord__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameListPage

@implementation GameListPage

@dynamic gamesArray, gamesArray_Count;
@dynamic pageNumber;
@dynamic pageSize;

typedef struct GameListPage__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageNumber;
  int32_t pageSize;
  NSMutableArray *gamesArray;
} GameListPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gamesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GameListEntry),
        .number = GameListPage_FieldNumber_GamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GameListPage__storage_, gamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GameListPage_FieldNumber_PageNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameListPage__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GameListPage_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameListPage__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameListPage class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameListPage__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameListEntry

@implementation GameListEntry

@dynamic hasGame, game;
@dynamic channelsArray, channelsArray_Count;
@dynamic onlineUserCount;
@dynamic userCount;
@dynamic hasMoreChannels;
@dynamic channelCount;

typedef struct GameListEntry__storage_ {
  uint32_t _has_storage_[1];
  int32_t onlineUserCount;
  int32_t userCount;
  int32_t channelCount;
  Game *game;
  NSMutableArray *channelsArray;
} GameListEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameListEntry_FieldNumber_Game,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameListEntry__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GameChannelListEntry),
        .number = GameListEntry_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GameListEntry__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onlineUserCount",
        .dataTypeSpecific.className = NULL,
        .number = GameListEntry_FieldNumber_OnlineUserCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameListEntry__storage_, onlineUserCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userCount",
        .dataTypeSpecific.className = NULL,
        .number = GameListEntry_FieldNumber_UserCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameListEntry__storage_, userCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hasMoreChannels",
        .dataTypeSpecific.className = NULL,
        .number = GameListEntry_FieldNumber_HasMoreChannels,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "channelCount",
        .dataTypeSpecific.className = NULL,
        .number = GameListEntry_FieldNumber_ChannelCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GameListEntry__storage_, channelCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameListEntry class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameListEntry__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameChannelListPage

@implementation GameChannelListPage

@dynamic hasGame, game;
@dynamic channelsArray, channelsArray_Count;
@dynamic pageNumber;
@dynamic pageSize;
@dynamic hasMoreChannels;

typedef struct GameChannelListPage__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageNumber;
  int32_t pageSize;
  Game *game;
  NSMutableArray *channelsArray;
} GameChannelListPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "game",
        .dataTypeSpecific.className = GPBStringifySymbol(Game),
        .number = GameChannelListPage_FieldNumber_Game,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameChannelListPage__storage_, game),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GameChannelListEntry),
        .number = GameChannelListPage_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GameChannelListPage__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GameChannelListPage_FieldNumber_PageNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameChannelListPage__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GameChannelListPage_FieldNumber_PageSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameChannelListPage__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hasMoreChannels",
        .dataTypeSpecific.className = NULL,
        .number = GameChannelListPage_FieldNumber_HasMoreChannels,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameChannelListPage class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameChannelListPage__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameChannelListEntry

@implementation GameChannelListEntry

@dynamic hasChannel, channel;
@dynamic onlineUserCount;
@dynamic userCount;

typedef struct GameChannelListEntry__storage_ {
  uint32_t _has_storage_[1];
  int32_t onlineUserCount;
  int32_t userCount;
  Channel *channel;
} GameChannelListEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(Channel),
        .number = GameChannelListEntry_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameChannelListEntry__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "onlineUserCount",
        .dataTypeSpecific.className = NULL,
        .number = GameChannelListEntry_FieldNumber_OnlineUserCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GameChannelListEntry__storage_, onlineUserCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userCount",
        .dataTypeSpecific.className = NULL,
        .number = GameChannelListEntry_FieldNumber_UserCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GameChannelListEntry__storage_, userCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameChannelListEntry class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameChannelListEntry__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Badge

@implementation Badge

@dynamic id_p;
@dynamic title;
@dynamic image;
@dynamic priority;

typedef struct Badge__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  NSString *id_p;
  NSString *title;
  NSString *image;
} Badge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Badge_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Badge__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Badge_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Badge__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = Badge_FieldNumber_Image,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Badge__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = Badge_FieldNumber_Priority,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Badge__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Badge class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Badge__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserBadge

@implementation UserBadge

@dynamic id_p;
@dynamic badgeId;
@dynamic userId;
@dynamic title;
@dynamic image;
@dynamic priority;
@dynamic timestamp;

typedef struct UserBadge__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  NSString *id_p;
  NSString *badgeId;
  NSString *userId;
  NSString *title;
  NSString *image;
  int64_t timestamp;
} UserBadge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserBadge__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "badgeId",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_BadgeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserBadge__storage_, badgeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserBadge__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserBadge__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_Image,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserBadge__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_Priority,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserBadge__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = UserBadge_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserBadge__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserBadge class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserBadge__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Tag

@implementation Tag

@dynamic name;

typedef struct Tag__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} Tag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Tag_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tag__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Tag class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tag__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BiographyUpdateData

@implementation BiographyUpdateData

@dynamic hasIntroduction, introduction;
@dynamic hasLanguages, languages;

typedef struct BiographyUpdateData__storage_ {
  uint32_t _has_storage_[1];
  OptionalString *introduction;
  OptionalString *languages;
} BiographyUpdateData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "introduction",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = BiographyUpdateData_FieldNumber_Introduction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BiographyUpdateData__storage_, introduction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "languages",
        .dataTypeSpecific.className = GPBStringifySymbol(OptionalString),
        .number = BiographyUpdateData_FieldNumber_Languages,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BiographyUpdateData__storage_, languages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BiographyUpdateData class]
                                     rootClass:[ProfileRoot class]
                                          file:ProfileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BiographyUpdateData__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
