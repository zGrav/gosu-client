// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Message.pbobjc.h"
 #import "Profile.pbobjc.h"
 #import "Any.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MessageRoot

@implementation MessageRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[ProfileRoot extensionRegistry]];
    [registry addExtensions:[AnyRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - MessageRoot_FileDescriptor

static GPBFileDescriptor *MessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - WebsocketMessage

@implementation WebsocketMessage

@dynamic messageOneOfCase;
@dynamic id_p;
@dynamic type;
@dynamic timestamp;
@dynamic channel;
@dynamic sender;
@dynamic userMessage;
@dynamic userAction;
@dynamic systemMessage;
@dynamic systemAction;
@dynamic recipient;
@dynamic recipientsArray, recipientsArray_Count;
@dynamic processedByCrawler;
@dynamic deleted;

typedef struct WebsocketMessage__storage_ {
  uint32_t _has_storage_[2];
  WebsocketMessage_MessageType type;
  NSString *id_p;
  NSString *timestamp;
  NSString *channel;
  NSString *sender;
  UserMessage *userMessage;
  UserMessage *userAction;
  SystemMessage *systemMessage;
  NSString *recipient;
  SystemAction *systemAction;
  NSMutableArray *recipientsArray;
} WebsocketMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = WebsocketMessage_MessageType_EnumDescriptor,
        .number = WebsocketMessage_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(UserMessage),
        .number = WebsocketMessage_FieldNumber_UserMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, userMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userAction",
        .dataTypeSpecific.className = GPBStringifySymbol(UserMessage),
        .number = WebsocketMessage_FieldNumber_UserAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, userAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "systemMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(SystemMessage),
        .number = WebsocketMessage_FieldNumber_SystemMessage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, systemMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recipient",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Recipient,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, recipient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemAction",
        .dataTypeSpecific.className = GPBStringifySymbol(SystemAction),
        .number = WebsocketMessage_FieldNumber_SystemAction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, systemAction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recipientsArray",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_RecipientsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WebsocketMessage__storage_, recipientsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "processedByCrawler",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_ProcessedByCrawler,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deleted",
        .dataTypeSpecific.className = NULL,
        .number = WebsocketMessage_FieldNumber_Deleted,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebsocketMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebsocketMessage__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "message",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t WebsocketMessage_Type_RawValue(WebsocketMessage *message) {
  GPBDescriptor *descriptor = [WebsocketMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:WebsocketMessage_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetWebsocketMessage_Type_RawValue(WebsocketMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [WebsocketMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:WebsocketMessage_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void WebsocketMessage_ClearMessageOneOfCase(WebsocketMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum WebsocketMessage_MessageType

GPBEnumDescriptor *WebsocketMessage_MessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000ChatMessage\000UserAction\000SystemMes"
        "sage\000Ping\000SystemAction\000";
    static const int32_t values[] = {
        WebsocketMessage_MessageType_Unknown,
        WebsocketMessage_MessageType_ChatMessage,
        WebsocketMessage_MessageType_UserAction,
        WebsocketMessage_MessageType_SystemMessage,
        WebsocketMessage_MessageType_Ping,
        WebsocketMessage_MessageType_SystemAction,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WebsocketMessage_MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WebsocketMessage_MessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WebsocketMessage_MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case WebsocketMessage_MessageType_Unknown:
    case WebsocketMessage_MessageType_ChatMessage:
    case WebsocketMessage_MessageType_UserAction:
    case WebsocketMessage_MessageType_SystemMessage:
    case WebsocketMessage_MessageType_Ping:
    case WebsocketMessage_MessageType_SystemAction:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageBodyAnnotation

@implementation MessageBodyAnnotation

@dynamic type;
@dynamic posStart;
@dynamic posEnd;
@dynamic replacement;
@dynamic target;
@dynamic proprietary;

typedef struct MessageBodyAnnotation__storage_ {
  uint32_t _has_storage_[1];
  MessageBodyAnnotation_SliceType type;
  int32_t posStart;
  int32_t posEnd;
  NSString *replacement;
  NSString *target;
  NSData *proprietary;
} MessageBodyAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = MessageBodyAnnotation_SliceType_EnumDescriptor,
        .number = MessageBodyAnnotation_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "posStart",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotation_FieldNumber_PosStart,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, posStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "posEnd",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotation_FieldNumber_PosEnd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, posEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "replacement",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotation_FieldNumber_Replacement,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, replacement),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotation_FieldNumber_Target,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "proprietary",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotation_FieldNumber_Proprietary,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MessageBodyAnnotation__storage_, proprietary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageBodyAnnotation class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageBodyAnnotation__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MessageBodyAnnotation_Type_RawValue(MessageBodyAnnotation *message) {
  GPBDescriptor *descriptor = [MessageBodyAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageBodyAnnotation_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetMessageBodyAnnotation_Type_RawValue(MessageBodyAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [MessageBodyAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageBodyAnnotation_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum MessageBodyAnnotation_SliceType

GPBEnumDescriptor *MessageBodyAnnotation_SliceType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Plaintext\000UserMention\000WebLink\000Ch"
        "annelLink\000Email\000Teamspeak\000Question\000";
    static const int32_t values[] = {
        MessageBodyAnnotation_SliceType_Unknown,
        MessageBodyAnnotation_SliceType_Plaintext,
        MessageBodyAnnotation_SliceType_UserMention,
        MessageBodyAnnotation_SliceType_WebLink,
        MessageBodyAnnotation_SliceType_ChannelLink,
        MessageBodyAnnotation_SliceType_Email,
        MessageBodyAnnotation_SliceType_Teamspeak,
        MessageBodyAnnotation_SliceType_Question,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageBodyAnnotation_SliceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageBodyAnnotation_SliceType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageBodyAnnotation_SliceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageBodyAnnotation_SliceType_Unknown:
    case MessageBodyAnnotation_SliceType_Plaintext:
    case MessageBodyAnnotation_SliceType_UserMention:
    case MessageBodyAnnotation_SliceType_WebLink:
    case MessageBodyAnnotation_SliceType_ChannelLink:
    case MessageBodyAnnotation_SliceType_Email:
    case MessageBodyAnnotation_SliceType_Teamspeak:
    case MessageBodyAnnotation_SliceType_Question:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageBodyAnnotationChannelLinkExtension

@implementation MessageBodyAnnotationChannelLinkExtension

@dynamic hasInvitation, invitation;

typedef struct MessageBodyAnnotationChannelLinkExtension__storage_ {
  uint32_t _has_storage_[1];
  MessageBodyAnnotationChannelLinkExtensionInvitation *invitation;
} MessageBodyAnnotationChannelLinkExtension__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invitation",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageBodyAnnotationChannelLinkExtensionInvitation),
        .number = MessageBodyAnnotationChannelLinkExtension_FieldNumber_Invitation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageBodyAnnotationChannelLinkExtension__storage_, invitation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageBodyAnnotationChannelLinkExtension class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageBodyAnnotationChannelLinkExtension__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageBodyAnnotationChannelLinkExtensionInvitation

@implementation MessageBodyAnnotationChannelLinkExtensionInvitation

@dynamic consumed;

typedef struct MessageBodyAnnotationChannelLinkExtensionInvitation__storage_ {
  uint32_t _has_storage_[1];
} MessageBodyAnnotationChannelLinkExtensionInvitation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "consumed",
        .dataTypeSpecific.className = NULL,
        .number = MessageBodyAnnotationChannelLinkExtensionInvitation_FieldNumber_Consumed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageBodyAnnotationChannelLinkExtensionInvitation class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageBodyAnnotationChannelLinkExtensionInvitation__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserMessage

@implementation UserMessage

@dynamic extensionOneOfCase;
@dynamic body;
@dynamic bodyAnnotationsArray, bodyAnnotationsArray_Count;
@dynamic hasUser, user;
@dynamic deletedTimestamp;
@dynamic deletedUser;
@dynamic type;
@dynamic conversationId;
@dynamic quote;
@dynamic website;
@dynamic attachmentsArray, attachmentsArray_Count;

typedef struct UserMessage__storage_ {
  uint32_t _has_storage_[2];
  UserMessage_Type type;
  NSString *body;
  NSMutableArray *bodyAnnotationsArray;
  ChatUser *user;
  NSString *deletedTimestamp;
  NSString *deletedUser;
  NSString *conversationId;
  NSString *quote;
  Website *website;
  NSMutableArray *attachmentsArray;
} UserMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = UserMessage_FieldNumber_Body,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bodyAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageBodyAnnotation),
        .number = UserMessage_FieldNumber_BodyAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserMessage__storage_, bodyAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = UserMessage_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deletedTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = UserMessage_FieldNumber_DeletedTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserMessage__storage_, deletedTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deletedUser",
        .dataTypeSpecific.className = NULL,
        .number = UserMessage_FieldNumber_DeletedUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserMessage__storage_, deletedUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = UserMessage_Type_EnumDescriptor,
        .number = UserMessage_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "conversationId",
        .dataTypeSpecific.className = NULL,
        .number = UserMessage_FieldNumber_ConversationId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserMessage__storage_, conversationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quote",
        .dataTypeSpecific.className = NULL,
        .number = UserMessage_FieldNumber_Quote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UserMessage__storage_, quote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "website",
        .dataTypeSpecific.className = GPBStringifySymbol(Website),
        .number = UserMessage_FieldNumber_Website,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(UserMessage__storage_, website),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attachmentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageAttachment),
        .number = UserMessage_FieldNumber_AttachmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserMessage__storage_, attachmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserMessage__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "extension",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserMessage_Type_RawValue(UserMessage *message) {
  GPBDescriptor *descriptor = [UserMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserMessage_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserMessage_Type_RawValue(UserMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UserMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserMessage_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void UserMessage_ClearExtensionOneOfCase(UserMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum UserMessage_Type

GPBEnumDescriptor *UserMessage_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Question\000";
    static const int32_t values[] = {
        UserMessage_Type_None,
        UserMessage_Type_Question,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserMessage_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserMessage_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserMessage_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserMessage_Type_None:
    case UserMessage_Type_Question:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageAttachment

@implementation MessageAttachment

@dynamic bodyOneOfCase;
@dynamic type;
@dynamic posStart;
@dynamic posEnd;
@dynamic fallbackURL;
@dynamic actionsArray, actionsArray_Count;
@dynamic quote;
@dynamic website;
@dynamic image;
@dynamic gallery;
@dynamic media;
@dynamic externalMedia;
@dynamic file;
@dynamic message;

typedef struct MessageAttachment__storage_ {
  uint32_t _has_storage_[2];
  MessageAttachment_AttachmentType type;
  int32_t posStart;
  int32_t posEnd;
  NSString *fallbackURL;
  NSMutableArray *actionsArray;
  NSString *quote;
  AttachmentWebsite *website;
  AttachmentImage *image;
  AttachmentImageGallery *gallery;
  AttachmentMedia *media;
  AttachmentExternalMedia *externalMedia;
  AttachmentFile *file;
  WebsocketMessage *message;
} MessageAttachment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = MessageAttachment_AttachmentType_EnumDescriptor,
        .number = MessageAttachment_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "posStart",
        .dataTypeSpecific.className = NULL,
        .number = MessageAttachment_FieldNumber_PosStart,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, posStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "posEnd",
        .dataTypeSpecific.className = NULL,
        .number = MessageAttachment_FieldNumber_PosEnd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, posEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fallbackURL",
        .dataTypeSpecific.className = NULL,
        .number = MessageAttachment_FieldNumber_FallbackURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, fallbackURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentAction),
        .number = MessageAttachment_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quote",
        .dataTypeSpecific.className = NULL,
        .number = MessageAttachment_FieldNumber_Quote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, quote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "website",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentWebsite),
        .number = MessageAttachment_FieldNumber_Website,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, website),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentImage),
        .number = MessageAttachment_FieldNumber_Image,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gallery",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentImageGallery),
        .number = MessageAttachment_FieldNumber_Gallery,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, gallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "media",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentMedia),
        .number = MessageAttachment_FieldNumber_Media,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "externalMedia",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentExternalMedia),
        .number = MessageAttachment_FieldNumber_ExternalMedia,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, externalMedia),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "file",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentFile),
        .number = MessageAttachment_FieldNumber_File,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, file),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = MessageAttachment_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MessageAttachment__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageAttachment class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageAttachment__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MessageAttachment_Type_RawValue(MessageAttachment *message) {
  GPBDescriptor *descriptor = [MessageAttachment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageAttachment_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetMessageAttachment_Type_RawValue(MessageAttachment *message, int32_t value) {
  GPBDescriptor *descriptor = [MessageAttachment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageAttachment_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void MessageAttachment_ClearBodyOneOfCase(MessageAttachment *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum MessageAttachment_AttachmentType

GPBEnumDescriptor *MessageAttachment_AttachmentType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Quote\000Image\000ImageGallery\000Video\000A"
        "udio\000Website\000Embed\000Document\000File\000Message"
        "\000ReplyTo\000ExternalTwitch\000ExternalYoutube\000"
        "ExternalVimeo\000ExternalSoundcloud\000";
    static const int32_t values[] = {
        MessageAttachment_AttachmentType_Unknown,
        MessageAttachment_AttachmentType_Quote,
        MessageAttachment_AttachmentType_Image,
        MessageAttachment_AttachmentType_ImageGallery,
        MessageAttachment_AttachmentType_Video,
        MessageAttachment_AttachmentType_Audio,
        MessageAttachment_AttachmentType_Website,
        MessageAttachment_AttachmentType_Embed,
        MessageAttachment_AttachmentType_Document,
        MessageAttachment_AttachmentType_File,
        MessageAttachment_AttachmentType_Message,
        MessageAttachment_AttachmentType_ReplyTo,
        MessageAttachment_AttachmentType_ExternalTwitch,
        MessageAttachment_AttachmentType_ExternalYoutube,
        MessageAttachment_AttachmentType_ExternalVimeo,
        MessageAttachment_AttachmentType_ExternalSoundcloud,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageAttachment_AttachmentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageAttachment_AttachmentType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageAttachment_AttachmentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageAttachment_AttachmentType_Unknown:
    case MessageAttachment_AttachmentType_Quote:
    case MessageAttachment_AttachmentType_Image:
    case MessageAttachment_AttachmentType_ImageGallery:
    case MessageAttachment_AttachmentType_Video:
    case MessageAttachment_AttachmentType_Audio:
    case MessageAttachment_AttachmentType_Website:
    case MessageAttachment_AttachmentType_Embed:
    case MessageAttachment_AttachmentType_Document:
    case MessageAttachment_AttachmentType_File:
    case MessageAttachment_AttachmentType_Message:
    case MessageAttachment_AttachmentType_ReplyTo:
    case MessageAttachment_AttachmentType_ExternalTwitch:
    case MessageAttachment_AttachmentType_ExternalYoutube:
    case MessageAttachment_AttachmentType_ExternalVimeo:
    case MessageAttachment_AttachmentType_ExternalSoundcloud:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AttachmentAction

@implementation AttachmentAction


typedef struct AttachmentAction__storage_ {
  uint32_t _has_storage_[1];
} AttachmentAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentAction class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AttachmentAction__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentWebsite

@implementation AttachmentWebsite

@dynamic URL;
@dynamic title;
@dynamic description_p;
@dynamic favicon;
@dynamic hasImage, image;
@dynamic hasMedia, media;

typedef struct AttachmentWebsite__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *title;
  NSString *description_p;
  NSString *favicon;
  AttachmentImage *image;
  AttachmentMedia *media;
} AttachmentWebsite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentWebsite_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentWebsite_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentWebsite_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "favicon",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentWebsite_FieldNumber_Favicon,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, favicon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentImage),
        .number = AttachmentWebsite_FieldNumber_Image,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "media",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentMedia),
        .number = AttachmentWebsite_FieldNumber_Media,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AttachmentWebsite__storage_, media),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentWebsite class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentWebsite__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentImage

@implementation AttachmentImage

@dynamic URL;
@dynamic width;
@dynamic height;
@dynamic placeholder;
@dynamic caption;
@dynamic mimeType;

typedef struct AttachmentImage__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *URL;
  NSData *placeholder;
  NSString *caption;
  NSString *mimeType;
} AttachmentImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "placeholder",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_Placeholder,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, placeholder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "caption",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_Caption,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, caption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentImage_FieldNumber_MimeType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AttachmentImage__storage_, mimeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentImage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentImage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentImageGallery

@implementation AttachmentImageGallery

@dynamic imagesArray, imagesArray_Count;

typedef struct AttachmentImageGallery__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *imagesArray;
} AttachmentImageGallery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AttachmentImage),
        .number = AttachmentImageGallery_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AttachmentImageGallery__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentImageGallery class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentImageGallery__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentMedia

@implementation AttachmentMedia

@dynamic URL;
@dynamic width;
@dynamic height;
@dynamic placeholder;
@dynamic previewURL;
@dynamic mimeType;

typedef struct AttachmentMedia__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *URL;
  NSData *placeholder;
  NSString *previewURL;
  NSString *mimeType;
} AttachmentMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "placeholder",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_Placeholder,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, placeholder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "previewURL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_PreviewURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, previewURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentMedia_FieldNumber_MimeType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AttachmentMedia__storage_, mimeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentMedia class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentMedia__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001!!!\000\005\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentExternalMedia

@implementation AttachmentExternalMedia

@dynamic URL;
@dynamic width;
@dynamic height;
@dynamic placeholder;
@dynamic previewURL;
@dynamic contentId;

typedef struct AttachmentExternalMedia__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  NSString *URL;
  NSData *placeholder;
  NSString *previewURL;
  NSString *contentId;
} AttachmentExternalMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "placeholder",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_Placeholder,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, placeholder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "previewURL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_PreviewURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, previewURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentId",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentExternalMedia_FieldNumber_ContentId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AttachmentExternalMedia__storage_, contentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentExternalMedia class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentExternalMedia__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001!!!\000\005\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AttachmentFile

@implementation AttachmentFile

@dynamic URL;
@dynamic title;
@dynamic preview;
@dynamic mimeType;
@dynamic encoding;
@dynamic size;

typedef struct AttachmentFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *title;
  NSString *preview;
  NSString *mimeType;
  NSString *encoding;
  int64_t size;
} AttachmentFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preview",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_Preview,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, preview),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_MimeType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, mimeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encoding",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_Encoding,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, encoding),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = AttachmentFile_FieldNumber_Size,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AttachmentFile__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AttachmentFile class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AttachmentFile__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Website

@implementation Website

@dynamic URL;
@dynamic title;
@dynamic description_p;
@dynamic image;
@dynamic video;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic type;
@dynamic contentId;

typedef struct Website__storage_ {
  uint32_t _has_storage_[1];
  int32_t imageWidth;
  int32_t imageHeight;
  Website_WebsiteType type;
  NSString *URL;
  NSString *title;
  NSString *description_p;
  NSString *image;
  NSString *video;
  NSString *contentId;
} Website__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Website__storage_, URL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Website__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Website__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_Image,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Website__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_Video,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Website__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_ImageWidth,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Website__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_ImageHeight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Website__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Website_WebsiteType_EnumDescriptor,
        .number = Website_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Website__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contentId",
        .dataTypeSpecific.className = NULL,
        .number = Website_FieldNumber_ContentId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Website__storage_, contentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Website class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Website__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Website_Type_RawValue(Website *message) {
  GPBDescriptor *descriptor = [Website descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Website_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetWebsite_Type_RawValue(Website *message, int32_t value) {
  GPBDescriptor *descriptor = [Website descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Website_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Website_WebsiteType

GPBEnumDescriptor *Website_WebsiteType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000TwitchChannel\000YoutubeVideo\000";
    static const int32_t values[] = {
        Website_WebsiteType_Default,
        Website_WebsiteType_TwitchChannel,
        Website_WebsiteType_YoutubeVideo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Website_WebsiteType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Website_WebsiteType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Website_WebsiteType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Website_WebsiteType_Default:
    case Website_WebsiteType_TwitchChannel:
    case Website_WebsiteType_YoutubeVideo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserAction

@implementation UserAction

@dynamic id_p;
@dynamic message;
@dynamic userId;
@dynamic channel;

typedef struct UserAction__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *message;
  NSString *userId;
  NSString *channel;
} UserAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = UserAction_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserAction__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserAction_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserAction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserAction_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserAction__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = UserAction_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserAction__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAction class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserAction__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemMessage

@implementation SystemMessage

@dynamic bodyOneOfCase;
@dynamic type;
@dynamic channel;
@dynamic typing;
@dynamic user;
@dynamic message;
@dynamic userVoiceStatus;
@dynamic messageBatch;
@dynamic userTypeV1;
@dynamic userType;
@dynamic hasPayload, payload;

typedef struct SystemMessage__storage_ {
  uint32_t _has_storage_[2];
  SystemMessage_MessageType type;
  ChannelUser_ChannelUserType userTypeV1;
  ChannelMembershipRecord_MembershipType userType;
  NSString *channel;
  TypingStatus *typing;
  ChatUser *user;
  NSString *message;
  UserVoiceStatusUpdate *userVoiceStatus;
  MessageBatch *messageBatch;
  Any *payload;
} SystemMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SystemMessage_MessageType_EnumDescriptor,
        .number = SystemMessage_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = SystemMessage_FieldNumber_Channel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "typing",
        .dataTypeSpecific.className = GPBStringifySymbol(TypingStatus),
        .number = SystemMessage_FieldNumber_Typing,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, typing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = SystemMessage_FieldNumber_User,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = SystemMessage_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTypeV1",
        .dataTypeSpecific.enumDescFunc = ChannelUser_ChannelUserType_EnumDescriptor,
        .number = SystemMessage_FieldNumber_UserTypeV1,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, userTypeV1),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userType",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_MembershipType_EnumDescriptor,
        .number = SystemMessage_FieldNumber_UserType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, userType),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userVoiceStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(UserVoiceStatusUpdate),
        .number = SystemMessage_FieldNumber_UserVoiceStatus,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, userVoiceStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageBatch",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageBatch),
        .number = SystemMessage_FieldNumber_MessageBatch,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, messageBatch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = GPBStringifySymbol(Any),
        .number = SystemMessage_FieldNumber_Payload,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SystemMessage__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemMessage__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SystemMessage_Type_RawValue(SystemMessage *message) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetSystemMessage_Type_RawValue(SystemMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SystemMessage_UserTypeV1_RawValue(SystemMessage *message) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_UserTypeV1];
  return GPBGetMessageInt32Field(message, field);
}

void SetSystemMessage_UserTypeV1_RawValue(SystemMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_UserTypeV1];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SystemMessage_UserType_RawValue(SystemMessage *message) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_UserType];
  return GPBGetMessageInt32Field(message, field);
}

void SetSystemMessage_UserType_RawValue(SystemMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [SystemMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemMessage_FieldNumber_UserType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void SystemMessage_ClearBodyOneOfCase(SystemMessage *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum SystemMessage_MessageType

GPBEnumDescriptor *SystemMessage_MessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Typing\000Status\000SystemMessage\000User"
        "Joined\000UserLeft\000FriendUpdated\000ReadStatus"
        "Update\000RequestToPull\000UserVoiceStatus\000Mes"
        "sageDeleted\000MessageBatchDeleted\000";
    static const int32_t values[] = {
        SystemMessage_MessageType_Unknown,
        SystemMessage_MessageType_Typing,
        SystemMessage_MessageType_Status,
        SystemMessage_MessageType_SystemMessage,
        SystemMessage_MessageType_UserJoined,
        SystemMessage_MessageType_UserLeft,
        SystemMessage_MessageType_FriendUpdated,
        SystemMessage_MessageType_ReadStatusUpdate,
        SystemMessage_MessageType_RequestToPull,
        SystemMessage_MessageType_UserVoiceStatus,
        SystemMessage_MessageType_MessageDeleted,
        SystemMessage_MessageType_MessageBatchDeleted,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SystemMessage_MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SystemMessage_MessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SystemMessage_MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SystemMessage_MessageType_Unknown:
    case SystemMessage_MessageType_Typing:
    case SystemMessage_MessageType_Status:
    case SystemMessage_MessageType_SystemMessage:
    case SystemMessage_MessageType_UserJoined:
    case SystemMessage_MessageType_UserLeft:
    case SystemMessage_MessageType_FriendUpdated:
    case SystemMessage_MessageType_ReadStatusUpdate:
    case SystemMessage_MessageType_RequestToPull:
    case SystemMessage_MessageType_UserVoiceStatus:
    case SystemMessage_MessageType_MessageDeleted:
    case SystemMessage_MessageType_MessageBatchDeleted:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SystemAction

@implementation SystemAction

@dynamic type;
@dynamic body;
@dynamic bodyAnnotationsArray, bodyAnnotationsArray_Count;
@dynamic hasPayload, payload;

typedef struct SystemAction__storage_ {
  uint32_t _has_storage_[1];
  SystemAction_Type type;
  NSString *body;
  NSMutableArray *bodyAnnotationsArray;
  Any *payload;
} SystemAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SystemAction_Type_EnumDescriptor,
        .number = SystemAction_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemAction__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = SystemAction_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemAction__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bodyAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageBodyAnnotation),
        .number = SystemAction_FieldNumber_BodyAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SystemAction__storage_, bodyAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = GPBStringifySymbol(Any),
        .number = SystemAction_FieldNumber_Payload,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemAction__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemAction class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemAction__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SystemAction_Type_RawValue(SystemAction *message) {
  GPBDescriptor *descriptor = [SystemAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemAction_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetSystemAction_Type_RawValue(SystemAction *message, int32_t value) {
  GPBDescriptor *descriptor = [SystemAction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SystemAction_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SystemAction_Type

GPBEnumDescriptor *SystemAction_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000General\000UserLoggedIn\000Donation\000";
    static const int32_t values[] = {
        SystemAction_Type_Unknown,
        SystemAction_Type_General,
        SystemAction_Type_UserLoggedIn,
        SystemAction_Type_Donation,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SystemAction_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SystemAction_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SystemAction_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case SystemAction_Type_Unknown:
    case SystemAction_Type_General:
    case SystemAction_Type_UserLoggedIn:
    case SystemAction_Type_Donation:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SystemActionPayloadUserLoggedIn

@implementation SystemActionPayloadUserLoggedIn

@dynamic hasFormerUser, formerUser;
@dynamic hasCurrentUser, currentUser;

typedef struct SystemActionPayloadUserLoggedIn__storage_ {
  uint32_t _has_storage_[1];
  ChatUser *formerUser;
  ChatUser *currentUser;
} SystemActionPayloadUserLoggedIn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "formerUser",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = SystemActionPayloadUserLoggedIn_FieldNumber_FormerUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemActionPayloadUserLoggedIn__storage_, formerUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentUser",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatUser),
        .number = SystemActionPayloadUserLoggedIn_FieldNumber_CurrentUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemActionPayloadUserLoggedIn__storage_, currentUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemActionPayloadUserLoggedIn class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemActionPayloadUserLoggedIn__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageBatch

@implementation MessageBatch

@dynamic start;
@dynamic end;

typedef struct MessageBatch__storage_ {
  uint32_t _has_storage_[1];
  NSString *start;
  NSString *end;
} MessageBatch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = MessageBatch_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageBatch__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = MessageBatch_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageBatch__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageBatch class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageBatch__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserVoiceStatusUpdate

@implementation UserVoiceStatusUpdate

@dynamic userId;
@dynamic userVoiceStatus;

typedef struct UserVoiceStatusUpdate__storage_ {
  uint32_t _has_storage_[1];
  ChannelMembershipRecord_VoiceStatus userVoiceStatus;
  NSString *userId;
} UserVoiceStatusUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserVoiceStatusUpdate_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserVoiceStatusUpdate__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userVoiceStatus",
        .dataTypeSpecific.enumDescFunc = ChannelMembershipRecord_VoiceStatus_EnumDescriptor,
        .number = UserVoiceStatusUpdate_FieldNumber_UserVoiceStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserVoiceStatusUpdate__storage_, userVoiceStatus),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserVoiceStatusUpdate class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserVoiceStatusUpdate__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserVoiceStatusUpdate_UserVoiceStatus_RawValue(UserVoiceStatusUpdate *message) {
  GPBDescriptor *descriptor = [UserVoiceStatusUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserVoiceStatusUpdate_FieldNumber_UserVoiceStatus];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserVoiceStatusUpdate_UserVoiceStatus_RawValue(UserVoiceStatusUpdate *message, int32_t value) {
  GPBDescriptor *descriptor = [UserVoiceStatusUpdate descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserVoiceStatusUpdate_FieldNumber_UserVoiceStatus];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - TypingStatus

@implementation TypingStatus

@dynamic userId;
@dynamic isTyping;

typedef struct TypingStatus__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} TypingStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = TypingStatus_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TypingStatus__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isTyping",
        .dataTypeSpecific.className = NULL,
        .number = TypingStatus_FieldNumber_IsTyping,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TypingStatus class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TypingStatus__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageWithMeta

@implementation MessageWithMeta

@dynamic hasMessage, message;
@dynamic hasSenderAgent, senderAgent;

typedef struct MessageWithMeta__storage_ {
  uint32_t _has_storage_[1];
  WebsocketMessage *message;
  UserAgent *senderAgent;
} MessageWithMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(WebsocketMessage),
        .number = MessageWithMeta_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageWithMeta__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "senderAgent",
        .dataTypeSpecific.className = GPBStringifySymbol(UserAgent),
        .number = MessageWithMeta_FieldNumber_SenderAgent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageWithMeta__storage_, senderAgent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageWithMeta class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageWithMeta__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
